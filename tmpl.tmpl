{{/* NAV TEMPLATE FRAGMENT */}}
{{define "nav"}}<nav>
	<p>Go-Fed</p>
	<ul>
		<li><a href="{{.Data.HomeData.Path}}">Home</a></li>
		<li><a href="{{.Data.GoFedTutorialData.Path}}">Go-Fed Overview</a></li>
		<li><a href="{{.Data.ActivityTutorialData.Path}}">App Tutorial</a></li>
		<li><a href="{{.Data.ActivityStreamsData.Path}}">activity/streams Reference</a></li>
		<li><a href="{{.Data.ActivityPubData.Path}}">activity/pub Reference</a></li>
		<li><a href="{{.Data.HttpSigData.Path}}">httpsig</a></li>
		<li><a href="{{.Data.ApCoreData.Path}}">apcore</a></li>
		<li><a href="{{.Data.ActivityPubGlanceData.Path}}">ActivityPub At A Glance</a></li>
	</ul>
</nav>{{end}}

{{/* CSS INLINE STYLE TEMPLATE FRAGMENT */}}
{{define "inlineStyle"}}<style>
h1, h2, h3, h4, h5, h6, p, a, label {
	margin: 0;
}
h1 {
	line-height: 1em;
}
body {
	background: #eaeaea;
	color: black;
	margin: 0;
	padding: 0;
	height: 100%;
}
#container {
	min-height: 100%;
	position: relative;
}
nav {
	display: flex;
	padding-left: 25px;
}
nav > p {
	font-weight: bold;
	font-size: 3em;
	color: #151515;
}
nav > ul {
	margin: auto 0;
}
nav > ul > li {
	display: inline-block;
	margin: 0.25em 0.25em;
	background: #740d00;
	border-radius: 5px;
	padding: 0.5em;
}
nav > ul > li > a {
	text-decoration: none;
	color: #ffffff;
}
#nav {
	font-family: Arial, sans-serif;
	background: #f38d7f;
	padding: 1em 0;
}
#body {
	font-family: Arial, sans-serif;
	line-height: 1.3em;
	padding-top: 25px;
	padding-left: 25px;
	padding-right: 25px;
	padding-bottom: 85px;
}
#body > h2 {
	margin-top: 1em;
	margin-bottom: 1em;
	background: #f38d7f;
	border-radius: 5px;
	padding: 0.5em;
}
#body > h3 {
	margin-left: 0.5em;
	margin-top: 1em;
	margin-bottom: 1em;
}
#body > p {
	margin: 1em 2em;
}
#body > ul {
	padding-left: 2em;
	margin: 1em 2em;
	list-style-type: disc;
}
#body > ul > li {
	padding-top: 0.2em;
	padding-bottom: 0.2em;
}
#body > ul > ul {
	padding-left: 2em;
	list-style-type: circle;
}
p > a, ol > li > a, h2 > a, h3 > a {
	text-decoration: none;
	color: #740d00;
}
p > a:hover, ol > li > a:hover, h2 > a:hover, h3 > a:hover {
	text-decoration: underline;
}
#body > ul > li > a {
	text-decoration: none;
	color: #740d00;
}
#body > ul > li > a:hover {
	text-decoration: underline;
}
#body > ul > ul > li > a {
	text-decoration: none;
	color: #740d00;
}
#body > ul > ul > li > a:hover {
	text-decoration: underline;
}
.permalink {
	display: none;
	text-decoration: none;
	margin-left: 0.5em;
	color: #740d00;
}
h2:hover > .permalink {
	display: inline;
}
h3:hover > .permalink {
	display: inline;
}
header {
	margin-bottom: 2em;
}
footer {
	font-family: Arial, sans-serif;
	background: #151515;
	color: #eaeaea;
	position: absolute;
	bottom: 0;
	width: 100%;
	height: 60px;
	padding-top: 1em;
}
footer > p {
	text-align: center;
}
footer > p > a {
	text-decoration: none;
	color: #f38d7f;
}
footer > p > a:hover {
	text-decoration: underline;
}
pre {
	background: #ffffff;
	border-radius: 5px;
	padding: 0.5em;
	font-size: 1.25em;
	overflow: auto;
	margin: 1em 2em;
}
.comment {
	color: #740d00;
}
.code {
	display: inline;
	font-family: monospace;
	font-size: 1.2em;
	background-color: #ffffff;
	border-radius: 5px;
	padding: 1px;
}
.keyword {
	color: #cc6500;
}
.type {
	color: #007700;
}
.literal {
	color: #0000dd;
}
aside {
	border-width: 2px;
	border-style: dashed;
	margin: 1em 4em;
	padding: 1em 1.5em;
}
aside > p {
	margin: 1em 1em
}
aside:before {
	display: block;
	font-size: 1.25em;
	margin-bottom: 1em;
}
aside.caution:before {
	content: "Caution!";
	color: #bf7300;
}
aside.caution {
	background: #ffca95;
	border-color: #ff9900;
}
aside.best:before {
	content: "Recommended Practice";
	color: #0000dd;
}
aside.best{
	background: #9999ff;
	border-color: #0000dd;
}
aside.advanced:before {
	content: "Unusual Use Case";
	color: #ff1818;
}
aside.advanced {
	background: #ffaaaa;
	border-color: #ff1818;
}
@media only screen and (max-width:550px) {
	nav > p {
		display: none;
	}
	#body {
		padding-top: 10px;
		padding-left: 10px;
		padding-right: 10px;
		padding-bottom: 70px;
	}
}
@media only screen and (max-width:480px) {
	nav > p {
		display: none;
	}
	#body {
		padding-top: 10px;
		padding-left: 0;
		padding-right: 0;
		padding-bottom: 70px;
	}
	#body > h2 {
		border-radius: 0;
	}
}
svg {
	display: block;
	margin: auto;
}
.svglibrary {
	stroke: black;
	stroke-width: 2;
	fill: none;
}
.svgtext { font: 30px sans-serif; }
.svgtextsmall { font: 20px sans-serif; }
.svgtextsmaller { font: 14px sans-serif; }
.svgdepline {
	stroke: black;
	stroke-width: 2;
	fill: none;
}
.svgjsonld { fill: lightblue; }
.svgas { fill: lightgreen; }
.svgap { fill: lightpink; }
.svgother { fill: lightgray; }
.svgapp { fill: lightyellow; }
.svgwip { stroke-dasharray: 2; }
.svgborder {
        stroke: black;
        stroke-width: 2;
        fill: none;
}
.svgactor {
  stroke-dasharray: 2;
  stroke: black;
  stroke-width: 2;
  fill: lightblue;
}
.svgpubactor {
  fill: lightgreen;
}
.svgashandler {
  fill: lightyellow;
}
.svgremotepeer {
  fill: lightpink;
}
.svgyoublock {
  fill: lightgray;
}
.svgyouline { stroke-dasharray: 2; }
.svginterface {
  fill: white;
}
</style>{{end}}

{{/* HEADER TEMPLATE FRAGMENT */}}
{{define "header"}}<html>
<head>
	<meta name="referrer" content="origin">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	{{range .Favicons}}
		<link rel="icon" href="{{.Path}}" type="image/png" sizes="{{.Size}}">
	{{end}}
	<title>{{.PageTitle}}</title>
	{{template "inlineStyle" .}}
</head>
<body>
<div id="container">
	<div id="nav">{{template "nav" .}}</div>
	<div id="body">
{{end}}

{{/* FOOTER TEMPLATE FRAGMENT */}}
{{define "footer"}}</div>
<footer>
	<p>go-fed Site and Documentation served by <a href="https://github.com/go-fed/site">go-fed/site</a></p>
	<p>Contact: <a href="https://mastodon.technology/@cj">@cj@mastodon.technology</a></p>
	<p>Dev Blog <a href="https://cjslep.com/c/blog/go-fed-2020">Go-Fed 2020</a></p>
</footer>
</div></body></html>{{end}}

{{/* NOT FOUND TEMPLATE */}}
{{define "notFound"}}{{template "header" .}}<header><h1>Not Found</h1></header>
<p>Sorry, nothing was found here!</p>
{{template "footer" .}}{{end}}

{{/* HOME TEMPLATE */}}
{{define "home"}}{{template "header" .C}}
<header><h1>ActivityPub in golang? Go Federate!</h1></header>
<p>- Tired of applications that silo its users?</p>
<p>- Want to join a decentralized network of social interactions?</p>
<p>- Have a golang app that lacks social functionality?</p>
<p>- Got a great social experience and looking to implement it in Go?</p>
<p>- Looking to extend the fediverse?</p>
<p>- Would you like a pony?</p>
<h2><a href="https://github.com/go-fed/activity">go-fed/activity</a> can help with all your non-equine needs!</h2>
<p>ActivityPub is a protocol that different social applications use to communicate
with each other. This lets users on
<a href="https://joinmastodon.org/">Mastodon</a>,
<a href="https://pleroma.social/">Pleroma</a>,
<a href="https://pixelfed.org/">PixelFed</a>,
<a href="https://joinpeertube.org/en/home/">PeerTube</a>,
and many other kinds of software talk, follow, share, and like each other's
content.</p>
<p>Whether you want to create a new social app or retrofit social
functionality into an existing one, ActivityPub lets everyone use each other's
network effect by pitching in together! This is the Fediverse.</p>
<p><a href="https://github.com/go-fed/activity">go-fed/activity</a> is unlike most other
software on the Fediverse. It is the first standalone ActivityPub library. It is
also the pioneering solution in golang.
It is designed for those who have no prior experience with ActivityPub, ActivityStreams,
JSON-LD, or RDF.</p>
<p>Come join the Federation and have your golang application support ActivityPub today!<p>
<p>Come start by reading the <a href="/overview">overview!</a><p>
<h2>About this site</h2>
<p>This site is the canonical resource for tutorials and documentation surrounding the
<a href="https://github.com/go-fed">go-fed</a> organization.</p>
{{template "footer" .C}}{{end}}

{{/* GO-FED TUTORIAL TEMPLATE */}}
{{define "gofedtutorial"}}{{template "header" .C}}
<header><h1>Go-Fed Overview</h1></header>
<h2>Table Of Contents</h2>
<ol>
<li><a href="#Go-Fed-Project">Go-Fed-Project</a></li>
<li><a href="#Libraries">Libraries</a></li>
<li><a href="#Next-Steps">Next Steps</a></li>
</ol>
<h2 id="Go-Fed-Project">The Go-Fed Project</h2>
<p>Go-Fed is a suite of libraries that lowers the barrier to writing Fediverse
apps in Golang. Libraries built under the go-fed umbrella follow the philosophy
of both a tech "stack" with composability" of other standards. For example,
developers can choose to use a minimal amount of the ActivityPub stack and
still opt to compose it with go/fed's library for HTTP Signatures, or to use the
ActivityPub stack without using go/fed's HTTP Signatures library.</p>
<p>A visual overview:</p>
<svg height="600" width="480">
  <!-- arrowhead definition -->
  <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6"
      markerHeight="6" orient="auto-start-reverse">
    <path d="M 0 0 L 10 5 L 0 10 z" />
  </marker>
  <!-- columns -->
  <text x = "20" y="30" class="svgtext">go-fed libraries</text>
  <text x="295" y="30" class="svgtext">concepts</text>
  <rect width="240" height="600" class="svglibrary" />
  <rect x="240" width="240" height="600" class="svglibrary" />
  
  <!-- concepts side -->
  <rect x="245" y="495" width="230" height="100" class="svglibrary svgjsonld" />
  <text x="290" y="555" class="svgtext">JSON-LD</text>
  <rect x="245" y="370" width="230" height="100" class="svglibrary svgas" />
  <text x="255" y="430" class="svgtext">ActivityStreams</text>
  <line x1="360" y1="495" x2="360" y2="475" class="svgdepline" marker-end="url(#arrow)" />
  <rect x="245" y="245" width="230" height="100" class="svglibrary svgap" />
  <text x="285" y="305" class="svgtext">ActivityPub</text>
  <line x1="360" y1="370" x2="360" y2="350" class="svgdepline" marker-end="url(#arrow)" />
  <rect x="360" y="120" width="115" height="100" class="svglibrary svgother" />
  <text x="395" y="165" class="svgtextsmall">Other</text>
  <text x="370" y="190" class="svgtextsmaller">(Http Sigs, etc.)</text>
  <rect x="245" y="45" width="230" height="50" class="svglibrary svgapp" />
  <text x="300" y="80" class="svgtext">Fedi app</text>
  <line x1="300" y1="245" x2="300" y2="100" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="420" y1="120" x2="420" y2="100" class="svgdepline" marker-end="url(#arrow)" />
  
  <!-- go-fed libraries side -->
  <rect x="5" y="495" width="230" height="100" class="svglibrary svgjsonld" />
  <text x="30" y="545" class="svgtextsmall">go-fed/activity/astool</text>
  <text x="70" y="565" class="svgtextsmaller">(at compile time)</text>
  <rect x="5" y="370" width="230" height="100" class="svglibrary svgas" />
  <text x="20" y="427" class="svgtextsmall">go-fed/activity/streams</text>
  <line x1="120" y1="495" x2="120" y2="475" class="svgdepline" marker-end="url(#arrow)" />
  <rect x="5" y="245" width="230" height="100" class="svglibrary svgap" />
  <text x="40" y="302" class="svgtextsmall">go-fed/activity/pub</text>
  <line x1="120" y1="370" x2="120" y2="350" class="svgdepline" marker-end="url(#arrow)" />
  <rect x="120" y="120" width="115" height="100" class="svglibrary svgother" />
  <text x="135" y="175" class="svgtextsmaller">go-fed/httpsig</text>
  <rect x="5" y="45" width="230" height="50" class="svglibrary svgapp svgwip" />
  <text x="60" y="75" class="svgtextsmall">go-fed/apcore</text>
  <line x1="60" y1="245" x2="60" y2="100" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="180" y1="120" x2="180" y2="100" class="svgdepline" marker-end="url(#arrow)" />
</svg>

<h2 id="Libraries">Libraries</h2>
<p>The ActivityPub stack is contained in the respository located at
<span class="code">github.com/go-fed/activity</span>. This is a monolithic
repository containing three more libraries, in order to address different
problems with generally mapping the ActivityPub spec into Golang.</p>
<p>ActivityPub is built on the exchange of JSON-LD data, which is not trivial to
map into Golang. The <span class="code">astool</span> command line tool reads
RDF schema definitions in order to generate code that produces strong types that
readily serialize and deserialize to and from JSON-LD. This is done at
compile-time, so your federating application can safely skip using this tool. If
you are interested in bringing new RDF vocabularies into go-fed, this is the
tool that makes it happen.</p>
<p>The ActivityStreams vocabulary is the basic vocabulary of ActivityPub. It is
an RDF schema, shared between peers as JSON-LD, and drives core behaviors
between Federated applications. The <span class="code">streams</span> library
is generated by the <span class="code">astool</span> to let federating apps in
Golang easily and safely manipulate ActivityStreams types.</p>
<p>Finally, the <span class="code">pub</span> library implements the barest
bones behaviors required by the ActivityPub specification. It is designed around
the actor model, and relies on Golang apps to implement quite a few interfaces.
The default behaviors help get a new app off the ground, but veteran
applications built on go-fed will find these behaviors customizable or entirely
overridable.</p>
<p>In the future, the <span class="code">github.com/go-fed/apcore</span> library
will be an opinionated, heavyweight framework to really speed up the minimal
code required to get a Federated app going. This is built on top of the
<span class="code">github.com/go-fed/activity</span> library, and offers some of
the same flexibility, but also injects more of the community's de-facto
standards instead of narrowly sticking to the ActivityPub specification.</p>
<p>An implementation of HTTP Signatures is provided by the
<span class="code">github.com/go-fed/httpsig</span> library. While the HTTP
Signatures specification is not mentioned in the ActivityPub specification, it
has been adopted by the community. It can be used independently of the other
libraries in the Go-Fed suite.</p>

<h2 id="Next-Steps">Next Steps</h2>
<p>Excited? The next step depends what you are looking for!</p>
<ul>
<li>Want to learn more about ActivityPub in general? Try
<a href="{{.C.Data.ActivityPubGlanceData.Path}}">ActivityPub Protocol At A
Glance</a></li>
<li>Want to use go-fed to get a small federated app off the ground? Head over to
the <a href="{{.C.Data.ActivityTutorialData.Path}}">App Tutorial</a></li>
<li>Simply need a refresher on how to use the libraries? Check out the
<a href="{{.C.Data.ActivityStreamsData.Path}}">activity/streams reference</a> or 
<a href="{{.C.Data.ActivityPubData.Path}}">activity/pub Reference</a>.</li>
</ul>
{{template "footer" .C}}{{end}}

{{/* ACTIVITY TUTORIAL TEMPLATE */}}
{{define "activitytutorial"}}{{template "header" .C}}
<header><h1>App Tutorial</h1></header>
<p>This tutorial goes through the steps necessary to build a federating
(Server-to-Server) application using
<a href="https://github.com/go-fed/activity">go-fed/activity</a> version
<span class="code">1.x</span>.</p>
<aside class="best"><p>Advice in these boxes call out suggested best
practices.</p></aside>
<aside class="caution"><p>Advice in these boxes call out pain
points.</p></aside>
<h2>Table Of Contents</h2>
<ol>
<li><a href="#Prepare">Prepare</a></li>
<li><a href="#ActivityPub-Mindset">An ActivityPub Mindset</a></li>
<li><a href="#Stubbing-Future">Stubbing For An Actor</a></li>
<li><a href="#Get-Federating-Actor">Get A Federating Actor</a></li>
<li><a href="#Hooking-It-All-Together">Hooking It All Together</a></li>
<li><a href="#Sending-Side">The Sending Side</a></li>
<li><a href="#Congratulations">Congratulations!</a></li>
<li><a href="#Further-Considerations">Further Considerations</a></li>
</ol>

<h2 id="Prepare">Prepare</h2>
<p>First, let's <span class="code">go get github.com/go-fed/activity</span>. Do
not worry if the <span class="code">go</span> tool complains about
<span class="code">package github.com/go-fed/activity: no Go files in
github.com/go-fed/activity</span> because there are no Go files in the root
library. This is OK, because we will be using the libraries under this directory
at <span class="code">github.com/go-fed/activity/streams</span> and
<span class="code">github.com/go-fed/activity/pub</span>.</p>
<p>Let's also start a new <span class="code">myapp</span> program with a
<span class="code">main</span> package, so we can start up a simple server from
the command line.</p>

<h2 id="ActivityPub-Mindset">An ActivityPub Mindset</h2>
<p>ActivityPub is built on the concept of an actor. An actor is simply an
entity, a person, a bot, or a logical unit of 'being'. Actors send and receive
messages to and from each other in a Federated way. This tutorial will outline
the concrete steps to do this, using go-fed.</p>
<aside class="best"><p>While this tutorial focuses exclusively on the
Server-to-Server (or S2S, or Federating Protocol) part of ActivityPub, it is
important to remember that ActivityPub defines 2 protocols! The other
federating protocol is Client-to-Server (or C2S, or Social
Protocol). Go-fed is designed for both.</p></aside>
<p>Let's take a look at what ActivityPub wants us to do, how go-fed approaches
it, and what we need to do to use go-fed.</p>
<p>ActivityPub is built on the concept of linked data: if the value isn't
literally there in a payload, a link (an IRI) is there so it can be fetched.
That means we'll need to serve some data at HTTP endpoints. On top of this,
actors name certain HTTP endpoints special things, like an "inbox" or "outbox".
Together, they logically form a presentation of the actor to the outside world.
We will also need to support the required ActivityPub behavior at the inbox and
outbox endpoints.</p>
<p>Here's a basic outline of the kinds of HTTP endpoints we will need:</p>
<svg height="500" width="480">
  <!-- arrowhead definition -->
  <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6"
      markerHeight="6" orient="auto-start-reverse">
    <path d="M 0 0 L 10 5 L 0 10 z" />
  </marker>
  <!-- main content -->
  <rect x="1" y="1" width="478" height="478" class="svgborder" />

  <!-- actor side -->
  <rect x="245" y="5" width="230" height="385" class="svgactor" />
  <text x="340" y="25" class="svgtextsmall">Actor</text>
  <text x="337" y="45" class="svgtextsmaller">Concept</text>
  
  <rect x="250" y="55" width="220" height="75" class="svgborder svgpubactor" />
  <text x="310" y="85" class="svgtextsmall">Actor Inbox</text>
  <text x="280" y="110" class="svgtextsmaller">HTTP POST*, HTTP GET*</text>
  
  <rect x="250" y="140" width="220" height="75" class="svgborder svgpubactor" />
  <text x="305" y="170" class="svgtextsmall">Actor Outbox</text>
  <text x="280" y="195" class="svgtextsmaller">HTTP POST**, HTTP GET</text>
  
  <rect x="250" y="225" width="220" height="75" class="svgborder svgashandler" />
  <text x="335" y="255" class="svgtextsmall">Actor</text>
  <text x="325" y="280" class="svgtextsmaller">HTTP GET</text>
  
  <rect x="250" y="310" width="220" height="75" class="svgborder svgashandler" />
  <text x="265" y="340" class="svgtextsmall">Followers, Liked, etc.</text>
  <text x="325" y="365" class="svgtextsmaller">HTTP GET</text>
  
  <rect x="245" y="400" width="230" height="75" class="svgborder svgashandler" />
  <text x="295" y="430" class="svgtextsmall">Other Content</text>
  <text x="325" y="455" class="svgtextsmaller">HTTP GET</text>
  
  <line x1="125" y1="35" x2="245" y2="35" class="svgdepline" />
  <line x1="125" y1="35" x2="125" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="110" y1="190" x2="110" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="95" y1="190" x2="95" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="140" y1="190" x2="140" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="155" y1="190" x2="155" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="95" y1="190" x2="155" y2="190" class="svgdepline" />

  <!-- remote peer side -->
  <rect x="70" y="225" width="110" height="75" class="svgborder svgremotepeer" />
  <text x="77" y="255" class="svgtextsmall">Peer Actor</text>
  <text x="87" y="280" class="svgtextsmaller">(Federating)</text>
  
  <line x1="180" y1="257" x2="210" y2="257" class="svgdepline" />
  <line x1="210" y1="87" x2="210" y2="432" class="svgdepline" />
  <line x1="210" y1="87" x2="245" y2="87" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="172" x2="245" y2="172" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="257" x2="245" y2="257" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="342" x2="245" y2="342" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="432" x2="240" y2="432" class="svgdepline" marker-end="url(#arrow)" />
  
  <!-- footnotes -->
  <rect x="1" y="479" width="478" height="20" class="svgborder" />
  <text x="5" y="493" class="svgtextsmaller">*Only S2S</text>
  <text x="120" y="493" class="svgtextsmaller">**Only C2S</text>
</svg>
<p>As you can see, the logical idea of presenting an actor has multiple sources
of data that need to be presented to the outside world in a cohesive manner.
That is represented by all the boxes in the blue "Actor" box above, and they
can be enriched with as much additional intrinsic details as your app requires.
Other forms of content not directly instrinsic to an actor, such as their notes
or articles they've written, also need to be exposed in ActivityStreams
form. That's the last box outside the blue "Actor" box.</p>
<p>Whatever the choice, the bare minimum required by ActivityPub are the inbox
and outbox behavior. go-fed makes the early design choice to support this via
an <span class="code">pub.Actor</span> interface. That's the green boxes above.
The light yellow are handled separately by
<span class="code">pub.HandlerFunc</span>. These two tools allow you to build
up the required behaviors.</p>
<p>However! Go-fed does <i>not</i> presume to know what kind of HTTP endpoints
you want to map, which means you are responsible for determining that, say,
<span class="code">https://example.com/arbitrary/actors/peyton</span> represents
an actor "peyton", but that
<span class="code">https://example.com/inboxes/peyton</span> is their inbox.
That means you have full control over your HTTP server, and
can defer behavior to go-fed when necessary.</p>
<p>Adding these layers to the previous image:</p>
<svg height="500" width="780">
  <!-- arrowhead definition -->
  <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6"
      markerHeight="6" orient="auto-start-reverse">
    <path d="M 0 0 L 10 5 L 0 10 z" />
  </marker>
  <!-- main content -->
  <rect x="1" y="1" width="478" height="478" class="svgborder" />

  <!-- actor side -->
  <rect x="245" y="5" width="230" height="385" class="svgactor" />
  <text x="340" y="25" class="svgtextsmall">Actor</text>
  <text x="337" y="45" class="svgtextsmaller">Concept</text>
  
  <rect x="250" y="55" width="220" height="75" class="svgborder svgpubactor" />
  <text x="310" y="85" class="svgtextsmall">Actor Inbox</text>
  <text x="280" y="110" class="svgtextsmaller">HTTP POST*, HTTP GET*</text>
  
  <rect x="250" y="140" width="220" height="75" class="svgborder svgpubactor" />
  <text x="305" y="170" class="svgtextsmall">Actor Outbox</text>
  <text x="280" y="195" class="svgtextsmaller">HTTP POST**, HTTP GET</text>
  
  <rect x="250" y="225" width="220" height="75" class="svgborder svgashandler" />
  <text x="335" y="255" class="svgtextsmall">Actor</text>
  <text x="325" y="280" class="svgtextsmaller">HTTP GET</text>
  
  <rect x="250" y="310" width="220" height="75" class="svgborder svgashandler" />
  <text x="265" y="340" class="svgtextsmall">Followers, Liked, etc.</text>
  <text x="325" y="365" class="svgtextsmaller">HTTP GET</text>
  
  <rect x="245" y="400" width="230" height="75" class="svgborder svgashandler" />
  <text x="295" y="430" class="svgtextsmall">Other Content</text>
  <text x="325" y="455" class="svgtextsmaller">HTTP GET</text>
  
  <line x1="125" y1="35" x2="245" y2="35" class="svgdepline" />
  <line x1="125" y1="35" x2="125" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="110" y1="190" x2="110" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="95" y1="190" x2="95" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="140" y1="190" x2="140" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="155" y1="190" x2="155" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="95" y1="190" x2="155" y2="190" class="svgdepline" />

  <!-- remote peer side -->
  <rect x="70" y="225" width="110" height="75" class="svgborder svgremotepeer" />
  <text x="77" y="255" class="svgtextsmall">Peer Actor</text>
  <text x="87" y="280" class="svgtextsmaller">(Federating)</text>
  
  <line x1="180" y1="257" x2="210" y2="257" class="svgdepline" />
  <line x1="210" y1="87" x2="210" y2="432" class="svgdepline" />
  <line x1="210" y1="87" x2="245" y2="87" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="172" x2="245" y2="172" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="257" x2="245" y2="257" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="342" x2="245" y2="342" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="432" x2="240" y2="432" class="svgdepline" marker-end="url(#arrow)" />
  
  <!-- footnotes -->
  <rect x="1" y="479" width="478" height="20" class="svgborder" />
  <text x="5" y="493" class="svgtextsmaller">*Only S2S</text>
  <text x="120" y="493" class="svgtextsmaller">**Only C2S</text>
  
  <!-- go-fed usage content -->
  <rect x="479" y="1" width="299" height="498" class="svgborder" />
  <rect x="500" y="87" width="110" height="350" class="svgborder svgyoublock" />
  <text x="515" y="245" class="svgtextsmall">MyServer</text>
  <text x="520" y="270" class="svgtextsmaller">Map HTTP</text>
  <text x="519" y="290" class="svgtextsmaller">Handlers to</text>
  <text x="519" y="310" class="svgtextsmaller">go-fed calls</text>
  
  <rect x="645" y="87" width="120" height="75" class="svgborder svgpubactor" />
  <text x="662" y="132" class="svgtextsmall">pub.Actor</text>
  <line x1="470" y1="92" x2="485" y2="92" class="svgdepline" />
  <line x1="470" y1="177" x2="485" y2="177" class="svgdepline" />
  <line x1="485" y1="92" x2="485" y2="177" class="svgdepline" />
  <line x1="485" y1="130" x2="500" y2="130" class="svgdepline" />
  <line x1="500" y1="130" x2="610" y2="130" class="svgdepline svgyouline" />
  <line x1="610" y1="130" x2="640" y2="130" class="svgdepline" marker-end="url(#arrow)" />
  
  <rect x="645" y="310" width="120" height="75" class="svgborder svgashandler" />
  <text x="650" y="355" class="svgtextsmaller">pub.HandlerFunc</text>
  <line x1="470" y1="262" x2="485" y2="262" class="svgdepline" />
  <line x1="470" y1="347" x2="485" y2="347" class="svgdepline" />
  <line x1="475" y1="437" x2="485" y2="437" class="svgdepline" />
  <line x1="485" y1="262" x2="485" y2="437" class="svgdepline" />
  <line x1="485" y1="347" x2="500" y2="347" class="svgdepline" />
  <line x1="500" y1="347" x2="610" y2="347" class="svgdepline svgyouline" />
  <line x1="610" y1="347" x2="640" y2="347" class="svgdepline" marker-end="url(#arrow)" />
</svg>
<p>All we need to do is get an <span class="code">pub.Actor</span>
and a <span class="code">pub.HandlerFunc</span>. These can be reused for any
number of handlers concurrently, for any number of actual logical actors.
To build these types, Go-fed breaks its requirements down into these two:</p>
<ul>
<li>A <span class="code">pub.Database</span> for persistent, concurrent-safe
storage.</li>
<li>A <i>behavior</i>, where you inject callbacks for go-fed to call in
order to have a comprehensive application supporting S2S, C2S, or both.</li>
</ul>
<p>The <span class="code">pub.Database</span> is a straightforward interface
that you need to implement, to meet the first requirement.</p>
<p>The <i>behavior</i> bit is trickier. The S2S and C2S parts of the ActivityPub
specification can be taken separately or together. Either way, parts of them
overlap. If go-fed defined all the S2S behaviors in one interface, and all
the C2S behaviors in another interface, then some methods would be duplicated!
Interfaces done in this way cannot be embedded into a
single interface for the S2S-plus-C2S case, since Golang will complain if two
interfaces define the same method. Remedying this leads to sub-optimal
interface design choices.</p>
<p>Therefore, go-fed actually breaks down the behavior into three interfaces:</p>
<ul>
<li>The <span class="code">pub.CommonBehavior</span> is the behavior required
regardless what kind of ActivityPub application you want. S2S, C2S, both? You
must implement this interface.</li>
<li>The <span class="code">pub.FederatingProtocol</span> is additional behavior
required <i>only</i> for any usage of S2S. This means the S2S-only case as well
as the S2S-plus-C2S case.</li>
<li>The <span class="code">pub.SocialProtocol</span> is additional behavior
required <i>only</i> for any usage of C2S. This means the C2S-only case as well
as the S2S-plus-C2S case.</li>
</ul>
<p>This still isn't optimal, but it at least follows the principle of
composability. It is recommended to implement these interfaces onto one concrete
type, so that all ActivityPub behavior is located in one place. Putting these
interfaces all together with the previous picture, we get:</p>
<svg height="500" width="1080">
  <!-- arrowhead definition -->
  <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6"
      markerHeight="6" orient="auto-start-reverse">
    <path d="M 0 0 L 10 5 L 0 10 z" />
  </marker>
  <!-- main content -->
  <rect x="1" y="1" width="478" height="478" class="svgborder" />

  <!-- actor side -->
  <rect x="245" y="5" width="230" height="385" class="svgactor" />
  <text x="340" y="25" class="svgtextsmall">Actor</text>
  <text x="337" y="45" class="svgtextsmaller">Concept</text>
  
  <rect x="250" y="55" width="220" height="75" class="svgborder svgpubactor" />
  <text x="310" y="85" class="svgtextsmall">Actor Inbox</text>
  <text x="280" y="110" class="svgtextsmaller">HTTP POST*, HTTP GET*</text>
  
  <rect x="250" y="140" width="220" height="75" class="svgborder svgpubactor" />
  <text x="305" y="170" class="svgtextsmall">Actor Outbox</text>
  <text x="280" y="195" class="svgtextsmaller">HTTP POST**, HTTP GET</text>
  
  <rect x="250" y="225" width="220" height="75" class="svgborder svgashandler" />
  <text x="335" y="255" class="svgtextsmall">Actor</text>
  <text x="325" y="280" class="svgtextsmaller">HTTP GET</text>
  
  <rect x="250" y="310" width="220" height="75" class="svgborder svgashandler" />
  <text x="265" y="340" class="svgtextsmall">Followers, Liked, etc.</text>
  <text x="325" y="365" class="svgtextsmaller">HTTP GET</text>
  
  <rect x="245" y="400" width="230" height="75" class="svgborder svgashandler" />
  <text x="295" y="430" class="svgtextsmall">Other Content</text>
  <text x="325" y="455" class="svgtextsmaller">HTTP GET</text>
  
  <line x1="125" y1="35" x2="245" y2="35" class="svgdepline" />
  <line x1="125" y1="35" x2="125" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="110" y1="190" x2="110" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="95" y1="190" x2="95" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="140" y1="190" x2="140" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="155" y1="190" x2="155" y2="220" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="95" y1="190" x2="155" y2="190" class="svgdepline" />

  <!-- remote peer side -->
  <rect x="70" y="225" width="110" height="75" class="svgborder svgremotepeer" />
  <text x="77" y="255" class="svgtextsmall">Peer Actor</text>
  <text x="87" y="280" class="svgtextsmaller">(Federating)</text>
  
  <line x1="180" y1="257" x2="210" y2="257" class="svgdepline" />
  <line x1="210" y1="87" x2="210" y2="432" class="svgdepline" />
  <line x1="210" y1="87" x2="245" y2="87" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="172" x2="245" y2="172" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="257" x2="245" y2="257" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="342" x2="245" y2="342" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="210" y1="432" x2="240" y2="432" class="svgdepline" marker-end="url(#arrow)" />
  
  <!-- footnotes -->
  <rect x="1" y="479" width="478" height="20" class="svgborder" />
  <text x="5" y="493" class="svgtextsmaller">*Only S2S</text>
  <text x="120" y="493" class="svgtextsmaller">**Only C2S</text>
  
  <!-- go-fed usage content -->
  <rect x="479" y="1" width="599" height="498" class="svgborder" />
  <rect x="500" y="87" width="110" height="350" class="svgborder svgyoublock" />
  <text x="515" y="245" class="svgtextsmall">MyServer</text>
  <text x="520" y="270" class="svgtextsmaller">Map HTTP</text>
  <text x="519" y="290" class="svgtextsmaller">Handlers to</text>
  <text x="519" y="310" class="svgtextsmaller">go-fed calls</text>
  
  <rect x="645" y="87" width="120" height="75" class="svgborder svgpubactor" />
  <text x="662" y="132" class="svgtextsmall">pub.Actor</text>
  <line x1="470" y1="92" x2="485" y2="92" class="svgdepline" />
  <line x1="470" y1="177" x2="485" y2="177" class="svgdepline" />
  <line x1="485" y1="92" x2="485" y2="177" class="svgdepline" />
  <line x1="485" y1="130" x2="500" y2="130" class="svgdepline" />
  <line x1="500" y1="130" x2="610" y2="130" class="svgdepline svgyouline" />
  <line x1="610" y1="130" x2="640" y2="130" class="svgdepline" marker-end="url(#arrow)" />
  
  <rect x="645" y="310" width="120" height="75" class="svgborder svgashandler" />
  <text x="650" y="355" class="svgtextsmaller">pub.HandlerFunc</text>
  <line x1="470" y1="262" x2="485" y2="262" class="svgdepline" />
  <line x1="470" y1="347" x2="485" y2="347" class="svgdepline" />
  <line x1="475" y1="437" x2="485" y2="437" class="svgdepline" />
  <line x1="485" y1="262" x2="485" y2="437" class="svgdepline" />
  <line x1="485" y1="347" x2="500" y2="347" class="svgdepline" />
  <line x1="500" y1="347" x2="610" y2="347" class="svgdepline svgyouline" />
  <line x1="610" y1="347" x2="640" y2="347" class="svgdepline" marker-end="url(#arrow)" />
  
  <rect x="790" y="10" width="155" height="60" class="svgborder svginterface" />
  <text x="797" y="45" class="svgtextsmaller">pub.CommonBehavior</text>
  <rect x="790" y="95" width="155" height="60" class="svgborder svginterface" />
  <text x="792" y="130" class="svgtextsmaller">pub.FederatingProtocol*</text>
  <rect x="790" y="180" width="155" height="60" class="svgborder svginterface" />
  <text x="805" y="215" class="svgtextsmaller">pub.SocialProtocol**</text>
  <rect x="790" y="265" width="155" height="60" class="svgborder svginterface" />
  <text x="825" y="300" class="svgtextsmaller">pub.Database</text>
  <rect x="760" y="400" width="155" height="60" class="svgborder svgyoublock" />
  <text x="782" y="435" class="svgtextsmall">MyDatabase</text>
  <rect x="920" y="400" width="155" height="60" class="svgborder svgyoublock" />
  <text x="952" y="435" class="svgtextsmall">MyService</text>
  
  <line x1="777" y1="300" x2="777" y2="45" class="svgdepline" />
  <line x1="777" y1="45" x2="785" y2="45" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="765" y1="125" x2="785" y2="125" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="777" y1="210" x2="785" y2="210" class="svgdepline" marker-end="url(#arrow)" />
  <line x1="777" y1="300" x2="785" y2="300" class="svgdepline" marker-end="url(#arrow)" />
  
  <line x1="765" y1="347" x2="820" y2="347" class="svgdepline" />
  <line x1="820" y1="347" x2="820" y2="330" class="svgdepline" marker-end="url(#arrow)" />
  
  <line x1="850" y1="325" x2="850" y2="395" class="svgdepline" marker-end="url(#arrow)" />
  
  <line x1="945" y1="45" x2="995" y2="45" class="svgdepline" />
  <line x1="945" y1="125" x2="995" y2="125" class="svgdepline" />
  <line x1="945" y1="210" x2="995" y2="210" class="svgdepline" />
  <line x1="995" y1="45" x2="995" y2="395" class="svgdepline" marker-end="url(#arrow)" />
</svg>

<p>Minor detail: there is also a <span class="code">pub.Clock</span> interface,
but it is not worth elaborating further upon.</p>
<p>Thus, this tutorial will concretely focus on a S2S demo app:</p>
<ul>
<li>Implementing <span class="code">pub.CommonBehavior</span></li>
<li>Implementing <span class="code">pub.FederatingProtocol</span></li>
<li>Implementing <span class="code">pub.Database</span></li>
<li>Acquiring and using a <span class="code">pub.Actor</span> in HTTP handlers,
specifically a <span class="code">pub.FederatingActor</span></li>
<li>Acquiring and using a <span class="code">pub.HandlerFunc</span> in HTTP
handlers</li>
<li>Programmatically sending messages to the Fediverse via the
<span class="code">pub.FederatingActor</span></li>
<li>Gloss over how to use ActivityStreams types and properties in the
<span class="code">github.com/go-fed/activity/streams</span> and
<span class="code">github.com/go-fed/activity/streams/vocab</span> packages</li>
</ul>

<h2 id="Stubbing-Future">Stubbing For An Actor</h2>
<p>Actors are at the core of the ActivityPub specification, so we will create
one in our application. We have the option to support either Client-to-Server,
Server-to-Server, or both forms of federation. We will only be supporting the
Server-to-Server option, so let's call
<span class="code">pub.NewFederatingActor</span>. Its signature looks like:</p>
<pre><span class="comment">// NewFederatingActor builds a new Actor concept that handles only the Federating</span>
<span class="comment">// Protocol part of ActivityPub.</span>
<span class="comment">//</span>
<span class="comment">// This Actor can be created once in an application and reused to handle</span>
<span class="comment">// multiple requests concurrently and for different endpoints.</span>
<span class="comment">//</span>
<span class="comment">// It leverages as much of go-fed as possible to ensure the implementation is</span>
<span class="comment">// compliant with the ActivityPub specification, while providing enough freedom</span>
<span class="comment">// to be productive without shooting one's self in the foot.</span>
<span class="comment">//</span>
<span class="comment">// Do not try to use NewSocialActor and NewFederatingActor together to cover</span>
<span class="comment">// both the Social and Federating parts of the protocol. Instead, use NewActor.</span>
<span class="keyword">func</span> NewFederatingActor(c <span class="type">CommonBehavior</span>,
	s2s <span class="type">FederatingProtocol</span>,
	db <span class="type">Database</span>,
	clock <span class="type">Clock</span>) <span class="type">FederatingActor</span>
</pre>
<p>Oh! Looks like we aren't ready to call it yet! We can see we will need to
pass in some interfaces. Let's stub out some types and revisit their
implementations later. First, the stub for the common behavior on a new type we
will internally call <span class="code">myService</span>:</p>
<pre><span class="keyword">type</span> <span class="type">myService</span> <span class="keyword">struct</span> {}
<span class="keyword">func</span> (*<span class="type">myService</span>) AuthenticateGetInbox(c <span class="type">context.Context</span>,
	w <span class="type">http.ResponseWriter</span>,
	r *<span class="type">http.Request</span>) (out <span class="type">context.Context</span>, authenticated <span class="type">bool</span>, err <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) AuthenticateGetOutbox(c <span class="type">context.Context</span>,
	w <span class="type">http.ResponseWriter</span>,
	r *<span class="type">http.Request</span>) (out <span class="type">context.Context</span>, authenticated <span class="type">bool</span>, err <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) GetOutbox(c <span class="type">context.Context</span>,
	r *<span class="type">http.Request</span>) (<span class="type">vocab.ActivityStreamsOrderedCollectionPage</span>, <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return nil</span>, <span class="keyword">nil</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) NewTransport(c <span class="type">context.Context</span>,
	actorBoxIRI *<span class="type">url.URL</span>,
	gofedAgent <span class="type">string</span>) (t <span class="type">pub.Transport</span>, err <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span>
}
</pre>
<p>Next up, let's stub out the methods for the <span class="code">FederatingProtocol</span>. Let's also
put them on the <span class="code">myService</span> type we just created:</p>
<pre><span class="keyword">func</span> (*<span class="type">myService</span>) PostInboxRequestBodyHook(c <span class="type">context.Context</span>,
	r *<span class="type">http.Request</span>,
	activity <span class="type">Activity</span>) (context.Context, error) {
	<span class="comment">// TODO</span>
	<span class="keyword">return nil</span>, <span class="keyword">nil</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) AuthenticatePostInbox(c <span class="type">context.Context</span>,
	w <span class="type">http.ResponseWriter</span>,
	r *<span class="type">http.Request</span>) (out <span class="type">context.Context</span>, authenticated <span class="type">bool</span>, err <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) Blocked(c <span class="type">context.Context</span>,
	actorIRIs []*<span class="type">url.URL</span>) (blocked <span class="type">bool</span>, err <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) Callbacks(c <span class="type">context.Context</span>) (wrapped <span class="type">FederatingWrappedCallbacks</span>, other []<span class="keyword">interface{}</span>, err <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) DefaultCallback(c <span class="type">context.Context</span>,
	activity <span class="type">Activity</span>) <span class="type">error</span> {
	<span class="comment">// TODO</span>
	<span class="keyword">return nil</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) MaxInboxForwardingRecursionDepth(c <span class="type">context.Context</span>) <span class="type">int</span> {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span> <span class="literal">-1</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) MaxDeliveryRecursionDepth(c <span class="type">context.Context</span>) <span class="type">int</span> {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span> <span class="literal">-1</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) FilterForwarding(c <span class="type">context.Context</span>,
	potentialRecipients []*<span class="type">url.URL</span>,
	a <span class="type">Activity</span>) (filteredRecipients []*<span class="type">url.URL</span>, err <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (*<span class="type">myService</span>) GetInbox(c <span class="type">context.Context</span>,
	r *<span class="type">http.Request</span>) (<span class="type">vocab.ActivityStreamsOrderedCollectionPage</span>, <span class="type">error</span>) {
	<span class="comment">// TODO</span>
	<span class="keyword">return nil</span>, <span class="keyword">nil</span>
}
</pre>
<p>Alright! Now for the database, let's create an in-memory based database. This
won't be good for a real application, but for a demo app it should suffice. A
real world applicaiton would want to use a real database solution under the hood
that can handle real persistence. Let us quickly write a database called
<span class="code">myDB</span>. We will begin to make use of the
<span class="code">github.com/go-fed/activity/pub</span> and
<span class="code">github.com/go-fed/activity/streams/vocab</span>
libraries.</p>
<aside class="caution"><p>It's important to note that the database implementation can be thought of
as being independent from ActivityStreams behaviors. So, don't confuse the
<span class="code">Create</span> ActivityStreams type with the Database
Create method we write.</p></aside>
<p>This is what a partial demo implementation could look like:</p>
<pre><span class="keyword">type</span> <span class="type">myDB</span> <span class="keyword">struct</span> {
	<span class="comment">// The content of our app, keyed by ActivityPub ID.</span>
	content *<span class="type">sync.Map</span>
	<span class="comment">// Enables mutations. A sync.Mutex per ActivityPub ID.</span>
	locks *<span class="type">sync.Map</span>
	<span class="comment">// The host domain of our service, for detecting ownership.</span>
	hostname <span class="type">string</span>
}

<span class="comment">// Our content map will store this data.</span>
<span class="keyword">type</span> <span class="type">content</span> <span class="keyword">struct</span> {
	<span class="comment">// The payload of the data: vocab.Type is any type understood by go-fed.</span>
	data <span class="type">vocab.Type</span>
	<span class="comment">// If true, belongs to our local user and not a federated peer. This is
	// recommended for a solution that just indiscriminately puts everything
	// into a single "table", like this in-memory solution.</span>
	isLocal <span class="type">bool</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Lock(c <span class="type">context.Context</span>,
	id *<span class="type">url.URL</span>) <span class="type">error</span> {
	<span class="comment">// Before any other Database methods are called, the relevant `id`
	// entries are locked to allow for fine-grained concurrency.</span>

	<span class="comment">// Strategy: create a new lock, if stored, continue. Otherwise, lock the
	// existing mutex.</span>
	mu := &amp;<span class="type">sync.Mutex</span>{}
	mu.Lock() <span class="comment">// Optimistically lock if we do store it.</span>
	i, loaded := m.locks.LoadOrStore(id.String(), mu)
	<span class="keyword">if</span> loaded {
		mu = i.(*<span class="type">sync.Mutex</span>)
		mu.Lock()
	}
	<span class="keyword">return nil</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Unlock(c <span class="type">context.Context</span>,
	id *<span class="type">url.URL</span>) <span class="type">error</span> {
	<span class="comment">// Once go-fed is done calling Database methods, the relevant `id`
	// entries are unlocked.</span>

	i, ok := m.locks.Load(id.String())
	<span class="keyword">if</span> !ok {
		<span class="keyword">return</span> errors.New(<span class="literal">"Missing an id in Unlock"</span>)
	}
	mu := i.(*<span class="type">sync.Mutex</span>)
	mu.Unlock()
	<span class="keyword">return nil</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Owns(c <span class="type">context.Context</span>,
	id *<span class="type">url.URL</span>) (owns <span class="type">bool</span>, err <span class="type">error</span>) {
	<span class="comment">// Owns just determines if the ActivityPub id is owned by this server.
	// In a real implementation, consider something far more robust than
	// this string comparison.</span>
	<span class="keyword">return</span> id.Host == m.hostname, <span class="keyword">nil</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Exists(c <span class="type">context.Context</span>,
	id *<span class="type">url.URL</span>) (exists <span class="type">bool</span>, err <span class="type">error</span>) {
	<span class="comment">// Do we have this `id`?</span>
	_, exists = m.content.Load(id.String())
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Get(c <span class="type">context.Context</span>,
	id *<span class="type">url.URL</span>) (value <span class="type">vocab.Type</span>, err <span class="type">error</span>) {
	<span class="comment">// Our goal is to return what we have at that `id`. Returns an error if
	// not found.</span>
	iCon, exists = m.content.Load(id.String())
	<span class="keyword">if</span> !exists {
		err = errors.New(<span class="literal">"Get failed"</span>)
		<span class="keyword">return</span>
	}
	<span class="comment">// Extract the data from our `content` type.</span>
	con := iCon.(*content)
	<span class="keyword">return</span> con.data
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Create(c <span class="type">context.Context</span>,
	asType <span class="type">vocab.Type</span>) <span class="type">error</span> {
	<span class="comment">// Create a payload in our in-memory map. The thing could be a local or
	// a federated peer's data. We can re-use the `Owns` call to set the
	// metadata on our `content`.</span>
	id, err := pub.GetId(asType)
	<span class="keyword">if</span> err != <span class="keyword">nil</span> {
		<span class="keyword">return</span> err
	}
	owns, err := m.Owns(id)
	<span class="keyword">if</span> err != <span class="keyword">nil</span> {
		<span class="keyword">return</span> err
	}
	con = &amp;<span class="type">content</span> {
		data: asType,
		isLocal: owns,
	}
	m.content.Store(id.String(), con)
	<span class="keyword">return nil</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Update(c <span class="type">context.Context</span>,
	asType <span class="type">vocab.Type</span>) <span class="type">error</span> {
	<span class="comment">// Replace a payload in our in-memory map. The thing could be a local or
	// a federated peer's data. Since we are using a map and not a solution
	// like SQL, we can simply do what `Create` does: overwrite it.
	//
	// Note that an actor's followers, following, and liked collections are
	// never Created, only Updated.</span>
	<span class="keyword">return</span> m.Create(c, asType)
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Delete(c <span class="type">context.Context</span>,
	id *<span class="type">url.URL</span>) <span class="type">error</span> {
	<span class="comment">// Remove a payload in our in-memory map.</span>
	m.Delete(id.String())
	<span class="keyword">return nil</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) InboxContains(c <span class="type">context.Context</span>,
	inbox,
	id *<span class="type">url.URL</span>) (contains <span class="type">bool</span>, err <span class="type">error</span>) {
	<span class="comment">// Our goal is to see if the `inbox`, which is an OrderedCollection,
	// contains an element in its `ordered_items` property that has a
	// matching `id`</span>
	contains = <span class="literal">false</span>
	<span class="keyword">var</span> oc <span class="type">vocab.ActivityStreamsOrderedCollection</span>
	<span class="comment">// getOrderedCollection is a helper method to fetch an
	// OrderedCollection. It is not implemented in this tutorial, and uses
	// the map m.content to do the lookup.</span>
	oc, err = m.getOrderedCollection(inbox)
	<span class="keyword">if</span> err != <span class="keyword">nil</span> {
		<span class="keyword">return</span>
	}
	<span class="comment">// Next, we use the ActivityStreams vocabulary to obtain the
	// ordered_items property of the OrderedCollection type.</span>
	oi := oc.GetActivityStreamsOrderedItems()
	<span class="comment">// Properties may be nil, if non-existent!</span>
	<span class="keyword">if</span> oi == <span class="keyword">nil</span> {
		<span class="keyword">return</span>
	}
	<span class="comment">// Finally, loop through each item in the ordered_items property and see
	// if the element's id matches the desired id.</span>
	<span class="keyword">for</span> iter := oi.Begin(); iter != oi.End(); iter = iter.Next() {
		<span class="keyword">var</span> iterId *<span class="type">url.URL</span>
		iterId, err = pub.ToId(iter)
		<span class="keyword">if</span> err != <span class="keyword">nil</span> {
			<span class="keyword">return</span>
		}
		<span class="keyword">if</span> iterId.String() == id.String() {
			contains = <span class="literal">true</span>
			<span class="keyword">return</span>
		}
	}
	<span class="keyword">return</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) GetInbox(c <span class="type">context.Context</span>,
	inboxIRI *<span class="type">url.URL</span>) (inbox <span class="type">vocab.ActivityStreamsOrderedCollectionPage</span>, err <span class="type">error</span>) {
	<span class="comment">// The goal here is to fetch an inbox at the specified IRI.</span>

	<span class="comment">// getOrderedCollectionPage is a helper method to fetch an
	// OrderedCollectionPage. It is not implemented in this tutorial, and
	// uses the map m.content to do the lookup and any conversions if
	// needed. The database can get fancy and use query parameters in the
	// `inboxIRI` to paginate appropriately.</span>
	<span class="keyword">return</span> m.getOrderedCollectionPage(inboxIRI)
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) SetInbox(c <span class="type">context.Context</span>,
	inbox <span class="type">vocab.ActivityStreamsOrderedCollectionPage</span>) <span class="type">error</span> {
	<span class="comment">// The goal here is to set an inbox at the specified IRI, with any
	// changes to the page made persistent. Since the inbox has been Locked,
	// it is OK to assume that no other concurrent goroutine has changed the
	// inbox in the meantime.</span>

	<span class="comment">// getOrderedCollection is a helper method to fetch an
	// OrderedCollection. It is not implemented in this tutorial, and
	// uses the map m.content to do the lookup.</span>
	storedInbox, err := m.getOrderedCollection(inboxIRI)
	<span class="keyword">if</span> err != <span class="keyword">nil</span> {
		<span class="keyword">return</span> err
	}
	<span class="comment">// applyDiffOrderedCollection is a helper method to apply changes due
	// to an edited OrderedCollectionPage. Implementation is left as an
	// exercise for the reader.</span>
	updatedInbox := m.applyDiffOrderedCollection(storedInbox, inbox)
	
	<span class="comment">// saveToContent is a helper method to save an
	// ActivityStream type. Implementation is left as an exercise for the
	// reader.</span>
	<span class="keyword">return</span> m.saveToContent(updatedInbox)
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) GetOutbox(c <span class="type">context.Context</span>,
	inboxIRI *<span class="type">url.URL</span>) (inbox <span class="type">vocab.ActivityStreamsOrderedCollectionPage</span>, err <span class="type">error</span>) {
	<span class="comment">// Similar to `GetInbox`, but for the outbox. See `GetInbox`.</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) SetOutbox(c <span class="type">context.Context</span>,
	inbox <span class="type">vocab.ActivityStreamsOrderedCollectionPage</span>) <span class="type">error</span> {
	<span class="comment">// Similar to `SetInbox`, but for the outbox. See `SetInbox`.</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) ActorForOutbox(c <span class="type">context.Context</span>,
	outboxIRI *<span class="type">url.URL</span>) (actorIRI *<span class="type">url.URL</span>, err <span class="type">error</span>) {
	<span class="comment">// Given the `outboxIRI`, determine the IRI of the actor that owns
	// that outbox. Will only be used for actors on this local server.
	// Implementation left as an exercise to the reader.</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) ActorForInbox(c <span class="type">context.Context</span>,
	inboxIRI *<span class="type">url.URL</span>) (actorIRI *<span class="type">url.URL</span>, err <span class="type">error</span>) {
	<span class="comment">// Given the `inboxIRI`, determine the IRI of the actor that owns
	// that inbox. Will only be used for actors on this local server.
	// Implementation left as an exercise to the reader.</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) OutboxForInbox(c <span class="type">context.Context</span>,
	inboxIRI *<span class="type">url.URL</span>) (outboxIRI *<span class="type">url.URL</span>, err <span class="type">error</span>) {
	<span class="comment">// Given the `inboxIRI`, determine the IRI of the outbox owned
	// by the same actor that owns the inbox. Will only be used for actors
	// on this local server. Implementation left as an exercise to the
	// reader.</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) NewId(c <span class="type">context.Context</span>,
	t <span class="type">vocab.Type</span>) (id *<span class="type">url.URL</span>, err <span class="type">error</span>) {
	<span class="comment">// Generate a new `id` for the ActivityStreams object `t`.</span>

	<span class="comment">// You can be fancy and put different types authored by different folks
	// along different paths. Or just generate a GUID. Implementation here
	// is left as an exercise for the reader.</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Followers(c <span class="type">context.Context</span>,
	actorIRI *<span class="type">url.URL</span>) (followers <span class="type">vocab.ActivityStreamsCollection</span>, err <span class="type">error</span>) {
	<span class="comment">// Get the followers collection from the actor with `actorIRI`.</span>

	<span class="comment">// getPerson is a helper method that returns an actor on this server
	// with a Person ActivityStreams type. It is not implemented in this tutorial.</span>
	<span class="keyword">var</span> person <span class="type">vocab.ActivityStreamsPerson</span>
	person, err = m.getPerson(actorIRI)
	<span class="keyword">if</span> err != <span class="keyword">nil</span> {
		<span class="keyword">return</span>
	}
	<span class="comment">// Let's get their followers property, ensure it exists, and then
	// fetch it with a familiar helper method.</span>
	f := person.GetActivityStreamsFollowers()
	<span class="keyword">if</span> f == <span class="keyword">nil</span> {
		err = errors.New(<span class="literal">"no followers collection"</span>)
		<span class="keyword">return</span>
	}
	<span class="comment">// Note: at this point f is not the OrderedCollection itself yet. It is
	// an opaque box (it could be an IRI, an OrderedCollection, or something
	// extending an OrderedCollection).</span>
	followersId, err := pub.ToId(f)
	<span class="keyword">if</span> err != <span class="keyword">nil</span> {
		<span class="keyword">return</span>
	}
	<span class="keyword">return</span> m.getOrderedCollection(followersId)
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Following(c <span class="type">context.Context</span>,
	actorIRI *<span class="type">url.URL</span>) (followers <span class="type">vocab.ActivityStreamsCollection</span>, err <span class="type">error</span>) {
	<span class="comment">// Get the following collection from the actor with `actorIRI`.</span>

	<span class="comment">// Implementation is similar to `Followers`. See `Followers`.</span>
}

<span class="keyword">func</span> (m *<span class="type">myDB</span>) Liked(c <span class="type">context.Context</span>,
	actorIRI *<span class="type">url.URL</span>) (followers <span class="type">vocab.ActivityStreamsCollection</span>, err <span class="type">error</span>) {
	<span class="comment">// Get the liked collection from the actor with `actorIRI`.</span>

	<span class="comment">// Implementation is similar to `Followers`. See `Followers`.</span>
}
</pre>
<p>Wow! OK, one more to go. The <span class="code">Clock</span> interface is
super easy, let's just tack on the one method to
<span class="code">myService</span>:</p>
<pre><span class="keyword">func</span> (*<span class="type">myService</span>) Now() <span class="type">time.Time</span> {
	<span class="keyword">return</span> time.Now()
}
</pre>
<p>Great! We can now get a <span class="code">FederatingActor</span>!</p>

<h2 id="Get-Federating-Actor">Get A Federating Actor</h2>
<p>With the stubs in the previous section, we can now properly obtain an actor
in our main method:</p>
<pre><span class="keyword">func</span> main() {
	s := &amp;<span class="type">myService</span>{}
	db := &amp;<span class="type">myDB</span>{
		content: &amp;<span class="type">sync.Map</span>{},
		locks: &amp;<span class="type">sync.Map</span>{},
		hostname: <span class="literal">"localhost"</span>,
	}
	actor := pub.NewFederatingActor(<span class="comment">/* CommonBehavior */</span> s,
		<span class="comment">/* FederatingProtocol */</span> s,
		<span class="comment">/* Database */</span> db,
		<span class="comment">/* Clock */</span> s)
}
</pre>
<p>There's two things left to do:</p>
<ol>
<li>Finish implementing the stubs for the federating behavior.</li>
<li>Hooking this actor into our HTTP server</li>
</ol>
<p>Let's tackle the first one here. The second one will be addressed in the
next section.</p>
<p>When we stubbed out the behaviors for the federating behaviors earlier, we
stubbed out functions that configure the actor's behavior within the ActivityPub
protocol, and we stubbed out the functions required to give us the juicy app
behaviors we want to customize. Configuration is boring, so let's revisit the
<span class="code">Callbacks</span> stubbed method.</p>
<p>The <span class="code">Callbacks</span> method's job is to provide the hooks
you want the go-fed library to call into when it receives an ActivityStreams
piece of data from a peer. It will have already passed through the other kinds
of checks you've configured such as Authentication and Blocked. Go-fed provides
a bunch of default behavior for you out of the box, so a valid implementation
that handles Activities like Create, Update, Delete, Add, Remove, and the others
listed in the specification is simply:</p>
<pre><span class="keyword">func</span> (*<span class="type">myService</span>) Callbacks(c <span class="type">context.Context</span>) (wrapped <span class="type">FederatingWrappedCallbacks</span>, other []<span class="keyword">interface{}</span>, err <span class="type">error</span>) {
	<span class="comment">// Return the default ActivityPub callbacks, and nothing in `other`.</span>
	<span class="keyword">return</span>
}
</pre>
<p>But defaults are boring! Let's say every time you get a Like from a peer, you
want your app to light up a disco ball light with your app's
<span class="code">DiscoParty</span> function. We can add that <i>in
addition</i> to the existing ActivityPub behavior of "adding a Like Activity to
the likes collection of all targeted Objects that are owned on this instance" by
doing this complicated maneuver:</p>
<pre><span class="keyword">func</span> (*<span class="type">myService</span>) Callbacks(c <span class="type">context.Context</span>) (wrapped <span class="type">FederatingWrappedCallbacks</span>, other []<span class="keyword">interface{}</span>, err <span class="type">error</span>) {
	wrapped = <span class="type">FederatingWrappedCallbacks</span>{
		<span class="comment">// Anything we set in the callbacks, is in *addition* to the out-of-the-box support.</span>
		Like: <span class="keyword">func</span>(c <span class="type">context.Context</span>, like <span class="type">vocab.ActivityStreamsLike</span>) <span class="type">error</span> {
			<span class="comment">// We could do something with the `like`, but for now it's time to party.</span>
			DiscoParty()
			<span class="keyword">return nil</span>
		},
	}
	<span class="keyword">return</span>
}
</pre>
<p>Next, let's say a federated peer gives your app a Flag Activity. But, the
<span class="code">FederatingWrappedCallbacks</span> doesn't have a spot for the
Flag Activity, because it isn't providing a default behavior! Oh no! World's
over, time to pack up and leave. Or, you simply put your callback in the
<span class="code">other</span> variable:</p>
<pre><span class="keyword">func</span> (*<span class="type">myService</span>) Callbacks(c <span class="type">context.Context</span>) (wrapped <span class="type">FederatingWrappedCallbacks</span>, other []<span class="keyword">interface{}</span>, err <span class="type">error</span>) {
	other = []<span class="type">interface{}</span>{
		<span class="comment">// Elements in `other` need to follow this function signature pattern.</span>
		<span class="keyword">func</span>(c <span class="type">context.Context</span>, flag <span class="type">vocab.ActivityStreamsFlag</span>) <span class="type">error</span> {
			<span class="comment">// We can now look at `flag` to turn the avatar of the person who got flagged
			// into a giant baby picture.</span>

			<span class="comment">// Note: you're in charge of checking `target` and `object` to make sure it is applicable.</span>
			<span class="keyword">return nil</span>
		},
	}
	<span class="keyword">return</span>
}
</pre>
<p>Finally, let's say you don't want a default behavior that go-fed provides out
of the box. Hey, no hard feelings. I get it, not every match is made in heaven.
There's a way to completely override the default behavior in a very delicate
way: simply provide the function in the <span class="code">other</span>
variable:</p>
<pre><span class="keyword">func</span> (*<span class="type">myService</span>) Callbacks(c <span class="type">context.Context</span>) (wrapped <span class="type">FederatingWrappedCallbacks</span>, other []<span class="keyword">interface{}</span>, err <span class="type">error</span>) {
	other = []<span class="type">interface{}</span>{
		<span class="comment">// This element follows the function signature pattern, but FederatingWrappedCallbacks
		// has a default for Add! Therefore, go-fed will pick the function here, completely replacing
		// the default behavior.</span>
		<span class="keyword">func</span>(c <span class="type">context.Context</span>, add <span class="type">vocab.ActivityStreamsAdd</span>) <span class="type">error</span> {
			<span class="comment">// This function does nothing, overriding the default behavior for the Add
			// Activity. In this case, it's like go-fed never provided a default at all.</span>
			<span class="keyword">return nil</span>
		},
	}
	wrapped = <span class="type">FederatingWrappedCallbacks</span>{
		<span class="comment">// Add's default behavior will NOT be called, but Activities like Create, Delete, etc will still
		// have their default behaviors called.</span>
		Add: <span class="keyword">func</span>(c <span class="type">context.Context</span>, add <span class="type">vocab.ActivityStreamsAdd</span>) <span class="type">error</span> {
			<span class="comment">// Will NOT be called, because it is a part of the Add default behavior,
			// which is being overridden!</span>
			<span class="keyword">return nil</span>
		},
	}
	<span class="keyword">return</span>
}
</pre>
<p>As you can see, when building your application you can start off using the
default behaviors provided by go-fed. Then, as it grows, you can completely
customize it as you see fit.</p>
<p>Let's breeze through the rest of the stubs discussing what is expected in
each in order to have an ActivityPub compliant implementation</p>
<ul>
<li><span class="code">AuthenticateGetInbox</span>: Provides a way for you to
deny GET HTTP ActivityPub requests for an actor's inbox. It is still compliant
to do nothing, though.</li>
<li><span class="code">AuthenticateGetOutbox</span>: Same as
<span class="code">AuthenticateGetInbox</span> but for outboxes.</li>
<li><span class="code">GetOutbox</span>: For the given
<span class="code">http.Request</span>, craft the right IRI and fetch the
outbox, which may be as simple as calling
<span class="code">myDB.GetOutbox</span></li>
<li><span class="code">GetInbox</span>: Similar to
<span class="code">GetOutbox</span> but for the inbox.</li>
<li><span class="code">NewTransport</span>: Returns a
<span class="code">Transport</span> which is responsible for physically shoving
bytes out the door, so to speak. One can be obtained by calling
<span class="code">pub.NewHttpSigTransport</span>, which is HTTP Signatures
based, or creating your own.</li>
<li><span class="code">PostInboxRequestBodyHook</span>: This is to make your
life easier in the HTTP request-handling cycle. This is a hook for you in case
you need to set up <span class="code">context.Context</span> based on the
<span class="code">http.Request</span> after the body has been read and
interpreted, but before it has been checked for authorization, blocks, etc.</li>
<li><span class="code">AuthenticatePostInbox</span>: Responsible for
authenticating the incoming peer message into the actor's inbox. The community
standard is HTTP Signatures, so this is where you would verify such a
signature.</li>
<li><span class="code">Blocked</span>: Given a list of actors, simply return
true if processing the Activity should stop. This prevents the peer message from
having any application-level side effects defined in
<span class="code">Callbacks</span>.</li>
<li><span class="code">DefaultCallback</span>: If a peer tries to send you
something that neither go-fed nor your app can understand, this will be called
with the offending Activity.</li>
<li><span class="code">MaxDeliveryRecursionDepth</span>: When your app attempts
to deliver messages, it may hit cases where a target is a list of actors, or
a list of a list of other actors, or even deeper nestings. This limits how far
your app will search before it quits building up its list of potential
recipients.</li>
<li><span class="code">MaxInboxForwardingRecursionDepth</span>: When doing inbox
forwarding in a deep chain of activities, this is the limit to how deep it will
search in order to attempt to determine if it should do inbox forwarding at
all.</li>
<li><span class="code">FilterForwarding</span>: Given a list of recipients for
the given activity, you MUST filter down the recipients in some way so that
your server does not blindly forward messages that are inappropriate when doing
inbox forwarding.</li>
</ul>
<aside class="caution"><p>The Activity passed into
<span class="code">PostInboxRequestBodyHook</span> should be treated as
untrusted, as it has not yet passed authorization.</p></aside>
<aside class="best"><p>Sizable but finite limits are strongly recommended for
<span class="code">MaxDeliveryRecursionDepth</span> and
<span class="code">MaxInboxForwardingRecursionDepth</span>.</p></aside>
<aside class="caution"><p>You MUST apply some sort of filtering in
<span class="code">FilterForwarding</span>, typically limiting it to followers
of the receiving actor, otherwise your application server will become a spam
vector. If that happens, communities using your software will be defederated
quickly.</p></aside>
<p>There we go! Now you have an actor-aware, ActivityPub ready implementation.
It is already hooked into the behaviors of your application. Now, all that
remains is to set up the HTTP routing to match the IRI paths used when creating
this implementation.</p>

<h2 id="Hooking-It-All-Together">Hooking It All Together</h2>
<p>An <span class="code">Actor</span>, like the
<span class="code">FederatingActor</span> we have, has only 4 methods (comments omitted):</p>
<pre><span class="keyword">type</span> <span class="type">Actor</span> <span class="keyword">interface</span> {
	PostInbox(c <span class="type">context.Context</span>, w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
	GetInbox(c <span class="type">context.Context</span>, w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
	PostOutbox(c <span class="type">context.Context</span>, w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
	GetOutbox(c <span class="type">context.Context</span>, w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
}</pre>
<p>These are built around handling an actor's inbox and outbox. It is sufficient
to call into these methods in a normal <span class="code">http.ServeMux</span>
that maps a path for an inbox or outbox. In fact, most of the challenge in
this section is mentally keeping track of which paths are meant to represent an
actor, their inbox, their outbox, etc. The paths you use to
hook into the <span class="code">http.ServeMux</span> will also need to match
the <span class="code">id</span> properties of the ActivityStreams data you
serve. If your <span class="code">Database</span> is designed to do this when
it is told to Get something, this property naturally arises.</p>
<p>For the demo app, let's only have one actor we want to logically represent:
me (aka: you)! Here is a basic set up:</p>
<pre>actor := pub.NewFederatingActor(s, s, db, s)
mux := http.NewServeMux()
<span class="comment">// Map the `me` actor's inbox to the path `/actors/me/inbox`</span>
mux.HandleFunc(<span class="literal">"/actors/me/inbox"</span>, <span class="keyword">func</span>(w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) {
	<span class="keyword">if</span> isActivityPubRequest, err := actor.GetInbox(w, r); err != <span class="keyword">nil</span> {
		<span class="comment">// Do something with `err`</span>
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest {
		<span class="comment">// Go-fed handled the ActivityPub GET request to the inbox</span>
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest, err := actor.PostInbox(w, r); err != <span class="keyword">nil</span> {
		<span class="comment">// Do something with `err`</span>
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest {
		<span class="comment">// Go-fed handled the ActivityPub POST request to the inbox</span>
		<span class="keyword">return</span>
	}
	<span class="comment">// Here we return an error, but you may just as well decide
	// to render a webpage instead. But be sure to apply appropriate
	// authorizations. There's no guarantees about authorization at
	// this point.</span>
	http.Error(<span class="literal">"Non-ActivityPub request"</span>, http.StatusBadRequest)
	<span class="keyword">return</span>
})
<span class="comment">// Map the `me` actor's inbox to the path `/arbitrary/me/outbox`</span>
mux.HandleFunc(<span class="literal">"/arbitrary/me/outbox"</span>, <span class="keyword">func</span>(w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) {
	<span class="keyword">if</span> isActivityPubRequest, err := actor.GetOutbox(w, r); err != <span class="keyword">nil</span> {
		<span class="comment">// Do something with `err`</span>
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest {
		<span class="comment">// Go-fed handled the ActivityPub GET request to the outbox</span>
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest, err := actor.PostOutbox(w, r); err != <span class="keyword">nil</span> {
		<span class="comment">// Do something with `err`</span>
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest {
		<span class="comment">// Go-fed handled the ActivityPub POST request to the outbox</span>
		<span class="keyword">return</span>
	}
	<span class="comment">// Here we return an error, but you may just as well decide
	// to render a webpage instead. But be sure to apply appropriate
	// authorizations. There's no guarantees about authorization at
	// this point.</span>
	http.Error(<span class="literal">"Non-ActivityPub request"</span>, http.StatusBadRequest)
	<span class="keyword">return</span>
})
</pre>
<aside class="best"><p>Rather than using non-sensical paths like
<span class="code">"/actors/me/inbox"</span> and
<span class="code">"/arbitrary/me/outbox"</span>, use
paths that make sense for your application and in a way that makes
sense. Examples will continue to use paths like these, only to show
that you still have the power to design your application's HTTP server
really well -- or really hard to understand.</p></aside>
<p>Pretty straightforward to use! Note here that we are using one
<span class="code">Actor</span> to logically map to one actor in our demo app.
This is not a limitation. A go-fed <span class="code">Actor</span> can handle
any number of actors, so feel free to use more complex Mux solutions that lets
you handle any number of actors, all calling into the same go-fed
<span class="code">Actor</span>. Think of the go-fed
<span class="code">Actor</span> being a definition of behavior, not state. It
is stateless, but your injected state via the
<span class="code">Database</span> gives it the data to operate on.</p>
<p>Finally, we need to serve our actor's ActivityStreams data itself. We're
serving the inbox and outbox now, which is dandy, but no one can discover them
since they are a part of the not-yet-served actor.</p>
<p>For any other data that isn't inboxes and outboxes, that is simply a GET
to a resource, the <span class="code">github.com/go-fed/activity/pub</span>
package has a helper that makes it a breeze:</p>
<pre>
<span class="comment">// NewActivityStreamsHandler creates a HandlerFunc to serve ActivityStreams</span>
<span class="comment">// requests which are coming from other clients or servers that wish to obtain</span>
<span class="comment">// an ActivityStreams representation of data.</span>
<span class="comment">//</span>
<span class="comment">// Strips retrieved ActivityStreams values of sensitive fields ('bto' and 'bcc')</span>
<span class="comment">// before responding with them. Sets the appropriate HTTP status code for</span>
<span class="comment">// Tombstone Activities as well.</span>
<span class="keyword">func</span> NewActivityStreamsHandler(db <span class="type">Database</span>, clock <span class="type">Clock</span>) <span class="type">HandlerFunc</span>
</pre>
<p>We've already created a <span class="code">Database</span> and a
<span class="code">Clock</span>, so obtaining one is easy:</p>
<pre>asHandler := pub.NewActivityStreamsHandler(db, s)
</pre>
<p>So, what is this <span class="code">HandlerFunc</span>? It's a function very
similar to the inbox and outbox functions on the
<span class="code">Actor</span>:</p>
<pre><span class="comment">// HandlerFunc determines whether an incoming HTTP request is an ActivityStreams</span>
<span class="comment">// GET request, and if so attempts to serve ActivityStreams data.</span>
<span class="comment">//</span>
<span class="comment">// If an error is returned, then the calling function is responsible for writing</span>
<span class="comment">// to the ResponseWriter as part of error handling.</span>
<span class="comment">//</span>
<span class="comment">// If 'isASRequest' is false and there is no error, then the calling function</span>
<span class="comment">// may continue processing the request, and the HandlerFunc will not have</span>
<span class="comment">// written anything to the ResponseWriter. For example, a webpage may be served</span>
<span class="comment">// instead.</span>
<span class="comment">//</span>
<span class="comment">// If 'isASRequest' is true and there is no error, then the HandlerFunc</span>
<span class="comment">// successfully served the request and wrote to the ResponseWriter.</span>
<span class="comment">//</span>
<span class="comment">// Callers are responsible for authorized access to this resource.</span>
<span class="keyword">type</span> HandlerFunc <span class="keyword">func</span>(c <span class="type">context.Context</span>, w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) (isASRequest <span class="type">bool</span>, err <span class="type">error</span>)
</pre>
<p>So if we wanted to serve our actor at a specific HTTP endpoint, we can do
the following:</p>
<pre><span class="comment">// Host the `me` actor at `/anything/me`</span>
mux.HandleFunc(<span class="literal">"/anything/me"</span>, <span class="keyword">func</span>(w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) {
	<span class="comment">// If any authentication/authorization needs to happen, apply it here</span>
	<span class="keyword">if</span> isActivityPubRequest, err := asHandler(r.Context(), w, r); err != <span class="keyword">nil</span> {
		<span class="comment">// Do something with `err`</span>
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest {
		<span class="comment">// Go-fed handled the ActivityPub GET request for this particular IRI</span>
		<span class="keyword">return</span>
	}
	<span class="comment">// Here we return an error, but you may just as well decide
	// to render a webpage instead. But be sure you've already
	// applied the appropriate authorizations.</span>
	http.Error(<span class="literal">"Non-ActivityPub request"</span>, http.StatusBadRequest)
	<span class="keyword">return</span>
})
</pre>
<aside class="caution"><p>Check your <span class="code">Database</span>'s Get
method to ensure that when returning "me" actor data for
<span class="code">"/anything/me"</span> the database is correctly setting the
inbox to <span class="code">"/actors/me/inbox"</span> and outbox to
<span class="code">"/arbitrary/me/outbox"</span>. Keeping your HTTP endpoints
and linked-data links in ActivityStreams synchronized is a necessary
headache.</p></aside>
<p>Similar to how the <span class="code">Actor</span> is a create-once and
use-multiple-times type, the <span class="code">HandlerFunc</span> can be reused
for every path you want to serve ActivityStreams data:</p>
<pre><span class="comment">// Notice we are serving a different endpoint for the disco.</span>
mux.HandleFunc(<span class="literal">"/disco/panic"</span>, <span class="keyword">func</span>(w <span class="type">http.ResponseWriter</span>, r *<span class="type">http.Request</span>) {
	<span class="comment">// If any authentication/authorization needs to happen, apply it here</span>

	<span class="comment">// Notice we are still using the same `asHandler`! Except in
	// this case, `myDB` will get a different IRI to load from the
	// datastore, which means this handler will serve different
	// ActivityStreams data.</span>
	<span class="keyword">if</span> isActivityPubRequest, err := asHandler(r.Context(), w, r); err != <span class="keyword">nil</span> {
		<span class="keyword">return</span>
	} <span class="keyword">else if</span> isActivityPubRequest {
		<span class="keyword">return</span>
	}
	http.Error(<span class="literal">"Non-ActivityPub request"</span>, http.StatusBadRequest)
	<span class="keyword">return</span>
})
</pre>
<aside class="caution"><p>Once data is served at a certain IRI, there is not a
well-established way in the community to migrate that content to another IRI.
Choose your HTTP paths wisely.</p></aside>
<p>Sweet! So far we've implemented some interfaces for our demo app, and hooked
them up to some HTTP handlers to handle incoming peer requests. Receiving
federated is nice and all, but what about sending federated messages? All that
remains in this tutorial is learning how to have our actors send out these
messages!</p>

<h2 id="Sending-Side">The Sending Side</h2>
<p>To send something to peers over the Fediverse, we need to first determine
what it is that our actor is doing. For our application, we will have our actor
send out a <span class="code">Note</span> to tell the world a very important
message. We want to tell federated peers that our actor created this
<span class="code">Note</span>, which is represented by using the
<span class="code">Create</span> activity.</p>
<p>The way to have go-fed send a federated message is to have a
<span class="code">FederatingActor</span>, and use its
<span class="code">Send</span> method. Not all <span class="code">Actor</span>
types are <span class="code">FederatingActor</span> because ActivityPub's C2S
specification doesn't have a peer-to-peer portion.</p>
<p>Fortunately, we already have a <span class="code">FederatingActor</span>.
On top of that, the <span class="code">Send</span> method has a special case
where if we give it something that isn't an <span class="code">Activity</span>,
it will automatically wrap it in a <span class="code">Create</span> for us!
Super convenient, since <span class="code">Create</span> is the most commonly
used activity.</p>
<p>Before we create a <span class="code">Note</span>, we need our
<span class="code">asHandler</span> serving the
<span class="code">asHandler</span> endpoint to serve an actor ActivityStreams
type, for peers to be able to examine. We can construct a
<span class="code">Person</span> and insert them into our in-memory database:</p>
<pre><span class="comment">// Create a ActivityStreams Person. Insertion into `myDB` is left as
// an exercise for the reader.</span>
person := streams.NewActivityStreamsPerson()

<span class="comment">// Set the `id` property of this actor, which should match
// what we are serving with `asHandler`.</span>
id, _ := url.Parse(<span class="literal">"https://example.com/anything/me"</span>)
idProperty := streams.NewJSONLDIdProperty()
idProperty.Set(id)

<span class="comment">// Set the `id` property on our Person.</span>
person.SetJSONLDId(idProperty)

<span class="comment">// Now we repeat for `inbox` and `outbox`. The IRI
// paths match the paths handled by `asHandler`.</span>
inbox, _ := url.Parse(<span class="literal">"https://example.com/actors/me/inbox"</span>)
inboxProperty := streams.NewActivityStreamsInboxProperty()
inboxProperty.SetIRI(inbox)
person.SetActivityStreamsInbox(inboxProperty)
outbox, _ := url.Parse(<span class="literal">"https://example.com/arbitrary/me/outbox"</span>)
outboxProperty := streams.NewActivityStreamsOutboxProperty()
outboxProperty.SetIRI(outbox)
person.SetActivityStreamsInbox(outboxProperty)

<span class="comment">// Let's set the `name` and `preferredUsername`
// properties, which are common on actors.</span>
nameProperty := streams.NewActivityStreamsNameProperty()
nameProperty.AppendXMLSchemaString(<span class="literal">"Arr, This Be Me Name"</span>)
person.SetActivityStreamsName(nameProperty)
preferredUsernameProperty := streams.NewActivityStreamsPreferredUsernameProperty()
preferredUsernameProperty.AppendXMLSchemaString(<span class="literal">"me"</span>) 
person.SetActivityStreamsPreferredUsername(preferredUsernameProperty)

<span class="comment">// The `followers`, `following`, `url` and `summary`
// properties are also recommended but left as an exercise for the reader.</span>
</pre>
<p>Now, let's create our <span class="code">Note</span>! Rather than sending the
overly-used trope of <span class="code">"Hello, World!"</span>, which would
stand out like a sore thumb and out us as n00bs, let's send a very boring
bland message to the Fediverse that either won't attract attention or get
hundreds of <span class="code">Announce</span> as an in-joke:</p>
<pre><span class="comment">// Obtain an ActivityStreams Note object.</span>
<span class="keyword">func</span> GetNote() <span class="type">streams.ActivityStreamsNote</span> {
	note := streams.NewActivityStreamsNote()

	<span class="comment">// Create the `id` property and set it -- be sure it is being served
	// by the `asHandler` (above) at the same path.</span>
	id, _ := url.Parse(<span class="literal">"https://example.com/some/path/to/this/note"</span>)
	idProperty := streams.NewJSONLDIdProperty()
	idProperty.Set(id)

	<span class="comment">// Set the `id` property on our Note.</span>
	note.SetJSONLDId(idProperty)

	<span class="comment">// Create the `content` property with a very typical Fediverse message.</span>
	contentProperty := streams.NewActivityStreamsContentProperty()
	contentProperty.AppendXMLSchemaString(<span class="literal">"jorts"</span>)
	note.SetActivityStreamsContent(contentProperty)

	<span class="comment">// Create the `attributedTo` property with our actor. Note that the
	// actor's IRI is the one being hosted by our `asHandler` above.</span>
	actorIRI, _ := url.Parse(<span class="literal">"https://example.com/anything/me"</span>)
	attrToProperty := streams.NewActivityStreamsAttributedToProperty()
	attrToProperty.AppendIRI(actorIRI)
	note.SetActivityStreamsAttributedTo(attrToProperty)

	<span class="comment">// Finally, send this `to` the public, and our actor's followers.</span>
	followersIRI, _ := url.Parse(<span class="literal">"https://example.com/anything/me/followers"</span>)
	toProperty := streams.NewActivityStreamsToProperty()
	toProperty.AppendIRI(followersIRI)
	toProperty.AppendIRI(pub.PublicActivityPubIRI)
	note.SetActivityStreamsTo(toProperty)

	<span class="keyword">return</span> note
}
</pre>
<p>Now, all that we need is to trigger this behavior:</p>
<pre>myNote := GetNote()
outboxIRI, _ := url.Parse(<span class="literal">"https://example.com/arbitrary/me/outbox"</span>)
ctx := context.Background()
<span class="comment">// Send the note out, programmatically!</span>
sentActivity, err := actor.Send(ctx, outboxIRI, myNote)
</pre>
<p>This will automatically wrap the <span class="code">Note</span> we created
within a new <span class="code">Create</span> Activity, and send it to this
particular actor's followers.</p>
<p>If you want to send a different Activity, or different kinds of
ActivityStreams objects, or set different properties on those objects, refer
to the 
<a href="https://www.w3.org/TR/activitystreams-core">ActivityStreams Core Specification</a>
and the
<a href="https://www.w3.org/TR/activitystreams-vocabulary">ActivityStreams Vocabulary</a>.
These properties and types are all represented in the
<span class="code">github.com/go-fed/activity/streams</span> and
<span class="code">github.com/go-fed/activity/streams/vocab</span>
packages, following the same pattern seen in this tutorial.</p>

<h2 id="Congratulations">Congratulations!</h2>
<p>Congratulations! You've created an ActivityPub demo application! It is not
straightforward, and the learning curve is steep, but you've put the sweat
equity in and hopefully learned a thing for two.</p>
<p>We saw a brief explanation how the go-fed interfaces work, and then stubbed
them out. We also saw a brief in-memory implementation of a datastore compatible
with go-fed. Next, we used these interfaces to get an actor. We served the actor
at various HTTP endpoints, but needed more. So we used a different handler to
serve non-actor endpoints. Finally, we hooked up a way to programmatically have
an actor send out messages across the Fediverse.</p>
<p>Pat yourself on the back, that was a huge amount of work!</p>
<h2 id="Further-Considerations">Further Considerations</h2>
<aside class="caution"><p>Under construction.</p></aside>
{{template "footer" .C}}{{end}}

{{/* AS REFERENCE TEMPLATE */}}
{{define "activitystreamsref"}}{{template "header" .C}}<header><h1>activity/streams Reference</h1></header>
<aside class="caution"><p>Under construction.</p></aside>
{{template "footer" .C}}{{end}}

{{/* AP REFERENCE TEMPLATE */}}
{{define "activitypubref"}}{{template "header" .C}}<header><h1>activity/pub Reference</h1></header>
<aside class="caution"><p>Under construction.</p></aside>
{{template "footer" .C}}{{end}}

{{/* HTTPSIGS REFERENCE TEMPLATE */}}
{{define "httpsigsref"}}{{template "header" .C}}<header><h1>httpsig Reference</h1></header>
<aside class="caution"><p>Under construction.</p></aside>
{{template "footer" .C}}{{end}}

{{/* APCORE REFERENCE TEMPLATE */}}
{{define "apcoreref"}}{{template "header" .C}}<header><h1>apcore Reference</h1></header>
<aside class="caution"><p>Under construction.</p></aside>
{{template "footer" .C}}{{end}}

{{/* ACTIVITY GLANCE TEMPLATE */}}
{{define "activityglance"}}{{template "header" .C}}<header><h1>ActivityPub At A Glance</h1></header>
<h2>Table Of Contents</h2>
<ol>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Under-Construction">Under Construction</a></li>
<li><a href="#References">References</a></li>
</ol>
<h2 id="Introduction">Introduction</h2>
<p>By the time you have finished with this page you will have a basic
and abstract understanding of how ActivityPub works. You will have enough
contextual knowledge to help make decisions when using this library. Those
already familiar with ActivityPub and ActivityStreams may find this page
redundant.</p>
<p>Let's begin!</p>
<p>ActivityPub is actually two protocols in one, but both govern application
behavior. The SocialAPI sets the rules for client-to-server interactions. When
implemented, an ActivityPub client could interact with any other ActivityPub
server. This lets a user use a single client on their phone
to talk to their accounts on different kinds of ActivityPub servers.</p>
<p>The FederateAPI governs how two servers share data which lets users on
all federating servers communicate with each other. Users on microblogs,
photoblogs, video sites, and your future application can all interact!</p>
<p>Despite providing both protocols, ActivityPub does not require both be
used. For example, Mastodon supports the FederateAPI but not the SocialAPI.
It is up to you and your application's needs whether you want to use one, the
other, or both!</p>
<p>To communicate, ActivityPub shares data in the ActivityStreams format. A
piece of ActivityStream data is encoded as JSON when examined on the wire.
However, it is actually built on top of JSON-LD which is a subset of JSON.
To summarize a very deep topic like JSON-LD, it does two things. One: it is a
rich data format (RDF) on top of JSON which effectively results in the JSON's
schema being embedded within each JSON message. Two: it allows pieces of JSON
data to refer to each other, resulting in a web of data that can be traversed
like a graph.</p>
<p>This means when sending and receiving ActivityStreams via ActivityPub, your
application is actually building a graph of data. As new data is
generated, the graph gets bigger. The idea of &quot;pointers&quot; to other
data looks like URLs, but they are technically IRIs.</p>
<p>The ActivityStreams specification doesn't just dictate a data format that is
a subset of JSON-LD, it also specifies Core and Extended types of data. These
are then used by ActivityPub to govern some basic behaviors in the SocialAPI and
FederateAPI. Specific examples of these Core and Extended data types will be
examined later on.</p>
<p>However, your application isn't limited to handling only Core and Extended
ActivityStream data types. Since it is built on top of JSON-LD, the
ActivityStreams vocabulary supports extensions beyond the Core and Extended
types. This will be outside the scope of this overview, but go-fed can handle
the expansion of RDF types at compile-time.</p>
<p>Let's also go over some things that ActivityPub does not support out of the
box. There may be community conventions around these topics, the details of
which are also outside the scope of this overview:</p>
<ul>
<li>The security protocols for authorization and authentication is not
standardized. Some choices I am aware of are OAuth 2.0 and HTTP Signatures.</li>
<li>Spam handling and blocking federating peers is not-standardized and
usually implemented as an administrative application feature.</li>
<li>The way to fetch a raw ActivityStream versus its human-readable HTML
representation in static servers is not currently standardized.</li>
</ul>

<h2 id="Under-Construction">Under Construction</h2>
<aside class="caution"><p>Under construction.</p></aside>

<h2 id="References">References</h2>
<p>These are the references I used or referred to when building all libraries within
the go-fed organization, including but not limited to the
<span class="code">go-fed/activity</span> library.</p>
<p>W3C Specifications:</p>
<ul>
<li><a href="https://www.w3.org/TR/social-web-protocols/">Social Web Protocols</a></li>
<li><a href="https://www.w3.org/TR/activitypub">The ActivityPub Specification</a></li>
<li><a href="https://www.w3.org/TR/activitystreams-core">The ActivityStreams Core Specification</a></li>
<li><a href="https://www.w3.org/TR/activitystreams-vocabulary">The ActivityStreams Vocabulary</a></li>
<li><a href="https://www.w3.org/ns/activitystreams">ActivityStream 2.0 Terms</a></li>
<li><a href="https://www.w3.org/TR/json-ld">The JSON-LD Specification</a></li>
</ul>
<p>RFCs:</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc3987">RFC 3987: Internationalized Resource Identifiers (IRIs)</a></li>
<li><a href="https://tools.ietf.org/html/rfc7033">RFC 7033: Webfinger</a></li>
<li><a href="https://tools.ietf.org/html/rfc3230">RFC 3230: Instance Digests in HTTP</a></li>
<li><a href="https://tools.ietf.org/html/rfc6749">RFC 6749: The OAuth 2.0 Authorization Framework</a></li>
<li><a href="https://tools.ietf.org/html/rfc6750">RFC 6750: The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></li>
<li><a href="https://tools.ietf.org/html/draft-cavage-http-signatures-10">DRAFT: Signing HTTP Messages</a></li>
</ul>
<p>Other documents and links:</p>
<ul>
<li><a href="https://www.w3.org/wiki/SocialCG/ActivityPub/Authentication_Authorization">ActivityPub Authentication And Authorization Conventions</a></li>
<li><a href="https://github.com/w3c/activitystreams">Github Repo for W3C ActivityStreams</a></li>
<li><a href="https://github.com/w3c/activitypub">Github Repo for W3C ActivityPub</a></li>
<li><a href="https://github.com/w3c-dvcg/http-signatures">Github Repo for W3C Draft of HTTP Signatures</a></li>
</ul>
{{template "footer" .C}}{{end}}

{{/* ACTIVITY TUTORIAL TEMPLATE */}}
{{define "oldactivitytutorial"}}{{template "header" .C}}<header><h1>The Go-Fed ActivityPub v1 Tutorials</h1></header>
<p>This focuses on how to use 
<a href="https://github.com/go-fed/activity">go-fed/activity</a> version
<span class="code">1.x</span> to create an application that implements ActivityPub in Go.<p>
<p>You will also see these scattered thoughout the tutorial:</p>
<aside class="best"><p>These boxes call out suggested best practices.</p></aside>
<aside class="caution"><p>These boxes call out tricky API details.</p></aside>
<aside class="advanced"><p>These boxes contain information for very advanced
use cases. They are not needed in typical applications, but for prototyping new
specifications.</p></aside>
<h2>Table Of Contents</h2>
<ol>
<li><a href="#Prerequisites">Prerequisites</a></li>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Library-Layout">Library Layout</a></li>
<li><a href="#ActivityStreams-Types-and-Properties">ActivityStreams: Types &amp; Properties</a></li>
<li><a href="#ActivityStreams-Serialization">ActivityStreams: Serialization</a></li>
<li><a href="#ActivityPub-The-Two-Protocols">ActivityPub: The Two Protocols</a></li>
<li><a href="#ActivityPub-SocialAPI">ActivityPub: SocialAPI (Client to Server)</a></li>
<li><a href="#ActivityPub-FederateAPI">ActivityPub: FederateAPI (Server to Server)</a></li>
<li><a href="#ActivityPub-Both-APIs">ActivityPub: Both APIs (Client to Server &amp; Server to Server)</a></li>
<li><a href="#References">References</a></li>
</ol>
<h2 id="Prerequisites">Prerequisites</h2>
<p>This tutorial assumes that you are familiar with the <a href="https://golang.org/">Go</a>
programming language. If not, I highly encourage you to take a look at the
<a href="https://tour.golang.org/">Tour of Go</a>.</p>
<p>No prior knowledge of ActivityPub is required. While this tutorial will neither contain
a complete nor deep overview of the protocol, it will contain enough pieces to
get you started with the basics. Those already familiar with the protocols may find
the next section uninteresting.</p>
<p>If at the end you are motivated to explore further, I have provided links to
primary source documents and repositories.</p>
<h2 id="Introduction">Introduction</h2>
<p>Welcome! By the time you have finished with this section you will have a basic
and abstract understanding of how ActivityPub works. You will have enough contextual
knowledge to help make decisions when using this library. Those already familiar
with ActivityPub and ActivityStreams can safely skip this section.</p>
<p>Let's begin!</p>
<p>ActivityPub is actually two protocols in one, but both govern application
behavior. The SocialAPI sets the rules for client-to-server interactions. When
implemented, an ActivityPub client could interact with any other ActivityPub
server. This lets a user use, for example, a single client on their phone
to talk to their accounts on different kinds of ActivityPub servers. The
FederateAPI governs how two servers share data which lets users on
all federating servers communicate with each other. Users on microblogs,
photoblogs, video sites, and your future application can all interact!</p>
<p>Despite providing both protocols, ActivityPub does not require both be
used. For example, Mastodon supports the FederateAPI but not the SocialAPI.
It is up to you and your application's needs whether you want to use one, the
other, or both!</p>
<p>To communicate, ActivityPub shares data in the ActivityStreams format. A
piece of ActivityStream data is encoded as JSON when examined on the wire.
However, it is actually built on top of JSON-LD which is a subset of JSON.
To summarize a very deep topic like JSON-LD, it does two things. One: it is a
rich data format (RDF) on top of JSON which effectively results in the JSON's
schema being embedded within each JSON message. Two: it allows pieces of JSON
data to refer to each other, resulting in a web of data that can be traversed
like a graph.</p>
<p>This means when sending and receiving ActivityStreams via ActivityPub, your
application is actually building a graph of data. As new data is
generated, the graph gets bigger. The idea of &quot;pointers&quot; to other
data looks like URLs, but they are technically IRIs.</p>
<p>The ActivityStreams specification doesn't just dictate a data format that is
a subset of JSON-LD, it also specifies Core and Extended types of data. These
are then used by ActivityPub to govern some basic behaviors in the SocialAPI and
FederateAPI. Specific examples of these Core and Extended data types will be
examined later on in the tutorial.</p>
<p>However, your application isn't limited to handling only Core and Extended
ActivityStream data types. Since it is built on top of JSON-LD, the
ActivityStreams vocabulary supports extensions beyond the Core and Extended
types. However, this will be outside the scope of this tutorial.</p>
<p>Let's also go over some things that ActivityPub does not support out of the
box. There may be community conventions around these topics, the details of
which are also outside the scope of this tutorial.</p>
<p>The security protocols for authorization and authentication is not
standardized. Some choices I am aware of are OAuth 2.0 and HTTP Signatures.</p>
<p>Spam handling and blocking federating peers is not-standardized and
usually implemented as an administrative application feature.</p>
<p>The way to fetch a raw ActivityStream versus its human-readable HTML
representation in static servers is not currently standardized.</p>
<p>You're now knowledgeable enough to dive into the library!</p>
<h2 id="Library-Layout">Library Layout</h2>
<p>The <span class="code">github.com/go-fed/activity</span> library is split
into two three core libraries.</p>
<p>The first core library is
<span class="code">github.com/go-fed/activity/vocab</span> which contains the
Core and Extended ActivityStreams types. The APIs of these types are large, but
it is by design. This library is code generated.</p>
<p>The second core library is
<span class="code">github.com/go-fed/activity/pub</span> which implements the
ActivityPub protocol. It heavily relies on your application satisfying
interfaces that are not trivial to implement. In exchange for implementing these
interfaces, the <span class="code">pub</span> types are very easy to hook into
new or existing code.</p>
<p>These two libraries are all you need during daily development. The third
library, <span class="code">github.com/go-fed/activity/astool</span>, is for
code generating the <span class="code">vocab</span> library and only of interest
if working with the ActivityPub specification itself.</p>
<p>Another library that may be helpful is
<span class="code">github.com/go-fed/httpsig</span> which you may find useful
to implement HTTP Signatures.
<h2 id="ActivityStreams-Types-and-Properties">ActivityStreams: Types &amp; Properties</h2>
<p>The
<span class="code">vocab</span>
package provides Go <span class="code keyword">interface</span> types that are
equivalent to the ActivityStream types and properties. It contains both Core
and Extended ActivityStream types plus properties. For example, to create a
<span class="code type">Note</span> type:
<p>An
<span class="code type">Object</span>
is created and its properties set or accessed in the following example:</p>
<pre><span class="comment">// Create an 'Object' type. Types are not copy-safe.</span>
obj := &amp;vocab.<span class="type">Object</span>{}

<span class="comment">// Add a value for the property 'name'</span>
obj.AppendNameString(<span class="literal">"Hello World"</span>)

<span class="comment">// Add a value for the property 'content'</span>
obj.AppendContentString(<span class="literal">"Here is some &lt;pre&gt;HTML&lt;/pre&gt; content"</span>)

<span class="comment">// Add two 'to' recipients</span>
addisonIRI, _ := url.Parse(<span class="literal">"https://www.example.com/addison"</span>)
obj.AppendToIRI(addisonIRI)
dakotaIRI, _ := url.Parse(<span class="literal">"https://www.example.com/dakota"</span>)
obj.AppendToIRI(dakotaIRI)

<span class="comment">// Now let's handle all of the possible values of 'to'</span>
<span class="keyword">for</span> i := 0; i < obj.ToLen(); i++ {
	<span class="keyword">if</span> obj.IsToObject(i) {
		<span class="comment">// Call obj.GetToObject(i)</span>
	} <span class="keyword">else if</span> obj.IsToLink(i) {
		<span class="comment">// Call obj.GetToLink(i)</span>
	} <span class="keyword">else if</span> obj.IsToIRI(i) {
		<span class="comment">// Call obj.GetToIRI(i)</span>
	}
}</pre>
<p>Each property has quite a few methods to deal with it. There are two kinds of
properties, which determines the methods available: properties that can have
multiple values and properties that can have at most one value. Properties that
can have multiple values are known as "non-functional" properties in the
ActivityStream specification. Properties that can have at most one value are
called "functional" properties.</p>
<p>For example, the <i>to</i>, <i>name</i>, and <i>content</i> properties are
all non-functional properties. Using <i>to</i> as
an example, for a non-functional property you need to be able to:</p>
<ul>
<li>Append a value on existing values of <i>to</i></li>
<li>Prepend a value on existing values of <i>to</i></li>
<li>Tell how many values of <i>to</i> there are</li>
<li>Determine what type of value <i>to</i> is at a specific index (the multiple
values of <i>to</i> do not have to be the same type!)</li>
<li>Get the value of <i>to</i> at a specific index with the correct type</li>
<li>Remove the value of <i>to</i> at a specific index with the correct type</li>
</ul>
<p>The methods available for the <i>to</i> property therefore are:</p>
<pre><span class="comment">// Append different types of 'to' values</span>
<span class="type">func</span> (o *<span class="type">Object</span>) AppendToObject(v ObjectType)
<span class="type">func</span> (o *<span class="type">Object</span>) AppendToLink(v LinkType)
<span class="type">func</span> (o *<span class="type">Object</span>) AppendToIRI(v *url.URL)

<span class="comment">// Prepend different types of 'to' values</span>
<span class="type">func</span> (o *<span class="type">Object</span>) PrependToObject(v ObjectType)
<span class="type">func</span> (o *<span class="type">Object</span>) PrependToLink(v LinkType)
<span class="type">func</span> (o *<span class="type">Object</span>) PrependToIRI(v *url.URL)

<span class="comment">// Determine the number of 'to' values</span>
<span class="type">func</span> (o *<span class="type">Object</span>) ToLen() (l int)

<span class="comment">// Determine what type a 'to' value is at a specific index</span>
<span class="type">func</span> (o *<span class="type">Object</span>) IsToObject(index int) (ok bool)
<span class="type">func</span> (o *<span class="type">Object</span>) IsToLink(index int) (ok bool)
<span class="type">func</span> (o *<span class="type">Object</span>) IsToIRI(index int) (ok bool)

<span class="comment">// Get a 'to' value at a specific index of the correct type</span>
<span class="type">func</span> (o *<span class="type">Object</span>) GetToObject(index int) (v ObjectType)
<span class="type">func</span> (o *<span class="type">Object</span>) GetToLink(index int) (v LinkType)
<span class="type">func</span> (o *<span class="type">Object</span>) GetToIRI(index int) (v *url.URL)

<span class="comment">// Remove a 'to' value at a specific index of the correct type</span>
<span class="type">func</span> (o *<span class="type">Object</span>) RemoveToObject(index int)
<span class="type">func</span> (o *<span class="type">Object</span>) RemoveToLink(index int)
<span class="type">func</span> (o *<span class="type">Object</span>) RemoveToIRI(index int)</pre>
<p>And for a functional property like <i>source</i>:</p>
<pre><span class="comment">// Determine what type a 'source' value is at a specific index.</span>
<span class="comment">// Note that getting and setting a property with one type is</span>
<span class="comment">// so common that method names omit ending the method with</span>
<span class="comment">// the type name if the only other acceptable type is an IRI</span>
<span class="comment">// In this case, "Object" is the only acceptable type.</span>
<span class="type">func</span> (o *<span class="type">Object</span>) IsSource() (ok bool)
<span class="type">func</span> (o *<span class="type">Object</span>) IsSourceIRI() (ok bool)

<span class="comment">// Get a 'source' value at a specific index of the correct type</span>
<span class="type">func</span> (o *<span class="type">Object</span>) GetSource() (v ObjectType)
<span class="type">func</span> (o *<span class="type">Object</span>) GetSourceIRI() (v *url.URL)

<span class="comment">// Set different types of 'source' values</span>
<span class="type">func</span> (o *<span class="type">Object</span>) SetSource(v ObjectType)
<span class="type">func</span> (o *<span class="type">Object</span>) SetSourceIRI(v *url.URL)</pre>
<aside class="best"><p>Now is a good time to remind you that while your
application can pick a subset of properties to support, you must support
as many types as allowed by the specification. Since this library matches the
specification, using all methods for a property will guarantee maximum
compatibility with the federation. Not doing so begins to
limit what your peers can do when federating or writing client software with
you. Ignoring property types is similar to ignoring
errors returned by golang functions, and is strongly discouraged. I
strongly recommend handling as many types on a property as possible.</p></aside>
<aside class="advanced"><p>You may also decide your application is required to
handle additional types for existing properties that are not being deserialized
by the
<span class="code">vocab</span>
or
<span class="code">streams</span>
libraries, or you may decide to support additional properties not listed in the
specification. In both cases the
<span class="code">vocab</span>
package provides the <i>unknown</i> set of APIs for each type and for each property:
<pre><span class="comment">// Unknown types for an existing property like 'replies'</span>
<span class="keyword">var</span> i <span class="keyword">interface</span>{}
obj.SetUnknownReplies(i)
<span class="keyword">if</span> obj.HasUnknownReplies(i) {
	<span class="comment">// Call obj.GetUnknownReplies(),
	// which returns an </span><span class="keyword">interface</span><span class="comment">{}</span>
}
<span class="comment">// Unknown properties on a type, where 'key' is its name</span>
<span class="keyword">var</span> key <span class="type">string</span>
obj.AddUnknown(key, i)
<span class="keyword">if</span> obj.HasUnknown(key) {
	<span class="comment">// Call obj.GetUnknown(key),
	// which returns an </span><span class="keyword">interface</span><span class="comment">{}</span>
}
obj.RemoveUnknown(key, i)
</pre>
Additional and better vocabulary support is targeted for the version
<span class="code">1.x</span>
release.
</p></aside>
<p>Repeat this for numerous properties on many different types, and the API
grows quite large. The size is large despite the restrictions
ActivityStreams imposes on top of JSON-LD, which is very flexible. If there is
one specification I would recommend keeping open while writing an ActivityStream
application, it would be the
<a href="https://www.w3.org/TR/activitystreams-vocabulary">ActivityStreams Vocabulary</a>.
It will help you learn more ActivityStreams types, ActivityStreams
properties, and the permitted value types of those properties.</p>
<p>There are also interfaces provided in the
<span class="code">vocab</span>
package for each type. The
<span class="code keyword">struct</span>
version of each type satisfies its corresponding interface. It shares the same
name as the ActivityStreams type with the world "Type" appended:</p>
<pre><span class="comment">// Setting concrete 'Object' struct to 'ObjectType' interface</span>
var objInterface vocab.<span class="type">ObjectType</span> = &amp;vocab.<span class="type">Object</span>{}</pre>
<p>While interfaces are provided for all classes, unrelated types may satisfy
each other's interfaces. This is because unrelated types may share the same
properties. The only interfaces that will filter correct children types are:</p>
<ul>
<li><span class="code type">ObjectType</span> for objects and types that extend objects</li>
<li><span class="code type">LinkType</span> for links and types that extend links</li>
<li><span class="code type">CollectionType</span> for unordered collections and pages of such collections</li>
<li><span class="code type">OrderedCollectionType</span> for ordered collections and pages of such collections</li>
</ul>
<p>Unfortunately, the
<span class="code type">Activity</span>
type requires inspecting the actual <i>type</i> property. The
<span class="code">vocab</span>
library provides such a function for you:</p>
<pre>var objType vocab.<span class="type">ObjectType</span> = ...
<span class="keyword">if</span> vocab.IsActivityType(objType) {
	<span class="comment">// 'objType' is an ActivityStreams activity.</span>
}</pre>
<aside class="caution">The interfaces <b>other than</b>
<span class="code type">ObjectType</span>,
<span class="code type">LinkType</span>,
<span class="code type">CollectionType</span>,
<span class="code type">OrderedCollectionType</span>, and
<span class="code type">ActivityType</span>
are highly likely to be removed in a major version release, so using them is 
discouraged.</aside>
<aside class="best">Use
<span class="code type">ObjectType</span>,
<span class="code type">LinkType</span>,
<span class="code type">CollectionType</span>, and
<span class="code type">OrderedCollectionType</span>
when you want to accept such generic types. However, to determine if an
<span class="code type">ObjectType</span> is an
<span class="code type">ActivityType</span>, use the
<span class="code type">IsActivityType</span> function.
</aside>
<p>The last piece of advice for properties I have is on IRIs. They take the
form of URLs. They can almost always take the place of actual data, and are
basically a pointer-over-HTTP. Whenever you see an IRI, know that fetching that
URL will "fill in" that piece of data from your peer's server. Whenever you
send out data with an IRI, you are telling your peers' servers that you will
host that ActivityStream data at that IRI location.</p>
<p>In the next sections, I will go over more types and properties from the
<a href="https://www.w3.org/TR/activitystreams-vocabulary">ActivityStreams Vocabulary specification</a>.</p>
<h3>Actor Types</h3>
<p>An actor type represents a <i>who</i> or <i>what</i> is doing an Activity.
These do not have to be human beings and could be an organization or another
computer. The types are:</p>
<ul>
<li><span class="code type">Object</span>: Represents a generic actor.</li>
<li><span class="code type">Application</span>: A software application.</li>
<li><span class="code type">Group</span>: Multiple actors in a single unit.</li>
<li><span class="code type">Organization</span>: An organization of some kind.</li>
<li><span class="code type">Person</span>: A human individual.</li>
<li><span class="code type">Service</span>: Any kind of service.</li>
</ul>
<p>All of these types have the same properties as
<span class="code type">Object</span>.</p>
<h3>Activity Types</h3>
<p>The meat of ActivityPub, an activity type represents what <i>action</i> is
being done. These are the root types that are shared between servers in
ActivityPub. Some common activiites are:</p>
<ul>
<li><span class="code type">Activity</span>: A generic base for other activity
types. By itself it lacks semantic meaning. Contains a <i>who</i> and a <i>to what</i>
(in English grammar: Direct Object)
this activity acts upon. Sometimes specifies a secondary <i>what</i> that is
being modified (in English grammar: Indirect Object).</li>
<li><span class="code type">IntransitiveActivity</span>: A generic base for other activity
types. It extends <span class="code type">Activity</span>, except it only has a
<i>who</i> and no <i>to what</i>. Sometimes specifies a secondary <i>what</i> that is
being modified (Indirect Object).</li>
<li><span class="code type">Create</span>: An actor is creating a new piece of
content.
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Update</span>: An actor is modifying an existing
piece of content.
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Delete</span>: An actor is removing an existing
piece of content.
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Follow</span>: An actor is requesting to follow
another actor.
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Block</span>: An actor is blocking another actor.
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Accept</span>: An actor is accepting something
(ex: a follow request).
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Reject</span>: An actor is rejecting something
(ex: a follow request).
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Add</span>: An actor is adding something to
something else (ex: adding an item to a collection).
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Remove</span>: An actor is removing something from
something else (ex: removing an item from a collection).
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Like</span>: An actor likes another piece of
content.
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Undo</span>: An actor is undo-ing a previous
action (ex: to undo a like as opposed to mistakenly disliking something already
liked).
Extends <span class="code type">Activity</span>.
</li>
<li><span class="code type">Announce</span>: An actor is sharing another
piece of content, from themselves or another user (ex: Mastodon's boost).
Extends <span class="code type">Activity</span>.
</li>
</ul>
<p>Some key additional properties of
<span class="code type">Activity</span>
are:</p>
<ul>
<li><i>actor</i>: The actor(s) who is/are performing the activity.</li>
<li><i>object</i>: The <i>to what</i> (Direct Object) that the activity is
acting upon (ex: The "note" in "Alex created a note"). Does not exist for
<span class="code type">IntransitiveActivity</span> types.</li>
<li><i>target</i>: The secondary <i>what</i> (Indirect Object) that the activity
is acting upon (ex: The "wishlist" in "Alex added a note to their wishlist").</li>
</ul>
<h3>Object/Link Types</h3>
<p>The
<span class="code type">Object</span>
and
<span class="code type">Link</span>
types both describe traditional pieces of application data. These are the things
that actors apply activities to. Note that the
<span class="code type">Object</span>
and
<span class="code type">Link</span>
types are specifically made <i>disjoint</i> in the specification, which just means
it is illegal to try to combine the two types together. Since there are very few
interesting types that extend
<span class="code type">Link</span>,
let's examine some that extend
<span class="code type">Object</span>:</p>
<ul>
<li><span class="code type">Note</span>: A short piece of text. This is a toot
in Mastodon, the unit of microblogging.</li>
<li><span class="code type">Image</span>: An image of any kind.</li>
<li><span class="code type">Profile</span>: An object that is describing another
object (typically an actor).</li>
<li><span class="code type">Tombstone</span>: A placeholder type for content
that was deleted. Allows preserving existing references without serving 404's.</li>
<li><span class="code type">Video</span>: A video of any kind.</li>
<li><span class="code type">Article</span>: A longer piece of text, typically
two or more paragraphs in length.</li>
<li><span class="code type">Audio</span>: A piece of audio of any kind.</li>
</ul>
<p>Most of these have no new properties besides the ones already provided by
<span class="code type">Object</span>. 
<span class="code type">Profile</span> and
<span class="code type">Tombstone</span> have some additional useful properties.
When in doubt, check the 
<a href="https://www.w3.org/TR/activitystreams-vocabulary">ActivityStreams Vocabulary specification</a>.</p>
<h2 id="ActivityStreams-Serialization">ActivityStreams: Serialization</h2>
<p>Conversion between a
<span class="code"><span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}</span>
and a concrete type is handled by a combination of the <span class="code">vocab</span>
and <span class="code">streams</span> packages. Serialization between raw JSON
(<span class="code">[]<span class="type">byte</span></span>) and 
<span class="code"><span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}</span>
is still handled by the standard
<span class="code">encoding/json</span>
library. This means the 
<span class="code">vocab</span>
and
<span class="code">streams</span>
packages are independent of the wire encoding.</p>
<p>Fortunately, all of this serialization, deserialization, and conversion is
routinely handled by the 
<span class="code">pub</span>
package, and won't be needed in your routine use of that library. However, it is
useful to know if you want to convert and encode these types as part of your own
database schemes (for example, as part of an application's Postgres JSON type).</p>
<h3>Serialization</h3>
<p>When given a <span class="code">vocab</span> concrete type, an
<span class="code type">Activity</span> for example,
it will satisfy the
<span class="code type">Serializer</span>
interface. It doesn't encode directly to JSON, but instead to a
<span class="code"><span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}</span>
which can then be used to encode to JSON:</p>
<pre><span class="type">type Serializer</span> <span class="keyword">interface</span> {
	Serialize() (m <span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}, e <span class="type">error</span>)
}</pre>
<p>Storing this JSON can then be done like:</p>
<pre>v := &amp;vocab.<span class="type">Activity</span>{}
m, _ := v.Serialize()
b, _ := json.Marshal(m)</pre>
<aside class="advanced">
<h4>Manually Sharing Serialized Objects</h4>
<p>If planning to share serialized data directly to the outside world without
using
<span class="code">pub</span>,
there is one caveat to calling 
<span class="code">Serialize</span>.
This use case should be extremely rare because you're probably trying to do one of
three things. One: you're trying to bypass
<span class="code">pub</span>
to do something borderline standard but technically allowed in ActivityPub.
Or, two: you are trying to propagate ActivityStreams data outside of the
ActivityPub protocol. Finally, three: you are trying to write your own
ActivityPub implementation on top of
<span class="code">vocab</span>.
</p>
<p>If the reasoning is the first one, please seriously reconsider the choice to
bypass
<span class="code">pub</span>,
and file an issue against the repository describing what functionality is
lacking that is causing you to pursue this. In typical ActivityPub usage
provided by
<span class="code">pub</span>,
what follows is unnecessary and won't impact typical usage.</p>
<p>The caveat: it is up to your
application to set the
<span class="code">@context</span>
correctly. This is because there is no mechanism to detect what kinds of
ActivityStream extensions you may be using in
<span class="code">vocab</span>.
It also does not know if the map
will be embedded in another map, and therefore automatically adding a
<span class="code">@context</span>
would be incorrect.</p>
<p>Currently, 
<span class="code">pub</span>
assumes only the core vocabulary is being used, so it does:</p>
<pre>v := &amp;vocab.<span class="type">Activity</span>{}
m, _ := v.Serialize()
m[<span class="literal">&quot;@context&quot;</span>] = <span class="literal">&quot;https://www.w3.org/ns/activitystreams&quot;</span></pre>
<p>Again, this use case should be extremely rare in your application. The
typical functionality in
<span class="code">pub</span>
should be sufficient for your needs.</p></aside>
<h3>Deserialization</h3>
<p>If given a raw set of
<span class="code">[]<span class="type">byte</span></span>,
both the
<span class="code">vocab</span>
and
<span class="code">streams</span>
packages are used to obtain a concrete type. First, decode the bytes to a
<span class="code"><span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}</span>
(with
<span class="code">encoding/json</span>
if JSON). OK, that was easy. Now, each 
<span class="code">vocab</span>
type implements a 
<span class="code type">Deserializer</span>
interface:</p>
<pre><span class="type">type Deserializer</span> <span class="keyword">interface</span> {
	Deserialize(m <span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}) (e <span class="type">error</span>)
}</pre>
<p>But the difficult question is: which 
<span class="code">vocab</span>
type should this map deserialize to?
<span class="code type">Activity</span>?
<span class="code type">Note</span>?
</p>
<p>Enter
<span class="code">Resolver</span>
in the
<span class="code">streams</span>
package. It detects the correct type and calls a callback into your code with
the concrete type deserialized:
<pre><span class="type">type Resolver</span> <span class="keyword">struct</span> {
	ObjectCallback <span class="type">func</span>(*<span class="type">Object</span>) <span class="type">error</span>
	LinkCallback <span class="type">func</span>(*<span class="type">Link</span>) <span class="type">error</span>
	ActivityCallback <span class="type">func</span>(*<span class="type">Activity</span>) <span class="type">error</span>
	CreateCallback <span class="type">func</span>(*<span class="type">Create</span>) <span class="type">error</span>
	AnyObjectCallback <span class="type">func</span>(*vocab.<span class="type">ObjectType</span>) <span class="type">error</span>
	AnyLinkCallback <span class="type">func</span>(*vocab.<span class="type">LinkType</span>) <span class="type">error</span>
	AnyActivityCallback <span class="type">func</span>(*vocab.<span class="type">ActivityType</span>) <span class="type">error</span>
	<span class="comment">// etc...</span>
}

func (t *<span class="type">Resolver</span>) Deserialize(m <span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}) (err <span class="type">error</span>) {
	<span class="comment">// Call the correct callbacks.</span>
}</pre>
<p>You do not need to set all of these callbacks to use the
<span class="code">Resolver</span>. Only set the ones you care about. It is OK
for ActivityPub implementations to ignore types that they are not meant to
handle. The giant list of all types is provided for flexibility, but can 
definitely seem intimidating.</p>
<p>The specific callbacks use the objects from the
<span class="code">stream</span>
package, not the objects from the
<span class="code">vocab</span>
package. On the other hand, the &quot;Any&quot; callbacks use interfaces from
the
<span class="code">vocab</span>
package.</p>
<p>The callbacks with the &quot;Any&quot; prefix will be called in addition to
the specific callback, based on the &quot;extends&quot; concept defined in the
ActivityStreams specification. For example, when deserializing a
<span class="code">Note</span>,
the
<span class="code">NoteCallback</span> and
<span class="code">AnyObjectCallback</span>
will be called since a
<span class="code">Note</span>
ultimately is extended from an
<span class="code">Object</span>.
<aside class="caution"><p>
Be careful mixing specific callbacks and callbacks with the
&quot;Any&quot; prefix. This can result in multiple callbacks getting called
at once when you may be expecting only one callback to be called.
</p></aside>
<p>Putting all of this together, deserializing would look like:</p>
<pre><span class="type">func</span> myNoteHandler(note *streams.<span class="type">Note</span>) <span class="type">error</span> {
	<span class="comment">// Use 'note' in your application</span>
}

<span class="type">func</span> myDeserializeFunc(b []<span class="type">byte</span>) <span class="type">error</span> {
	r := &amp;streams.<span class="type">Resolver</span> {
		NoteCallback: myNoteHandler,
	}
	var m <span class="type">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}
	<span class="keyword">if</span> e := json.Unmarshal(b, &amp;m); e != <span class="literal">nil</span> {
		<span class="keyword">return</span> e
	}
	<span class="keyword">return</span> r.Deserialize(m)
}</pre>
<h2 id="ActivityPub-The-Two-Protocols">ActivityPub: The Two Protocols</h2>
<p>While ActivityStreams defines the data structures being passed around, the
ActivityPub protocol defines key behaviors to get very different applications
to behave well together. While the SocialAPI and FederateAPI define different
behaviors, there are some shared concepts. We will go
over these concepts in this section.</p>
<p>Before we begin, understand that abstracting the ActivityPub protocol from
an application is very difficult. However, 
<span class="code">pub</span>
is able to handle a lot of the default lifting for you, and follows a "just
works" mentality while providing you with as much specification-compliant
flexibility as possible. Don't get discouraged from rapidly prototyping, but
understand this takes some serious effort to get right. And this library is
geared towards the latter.</p>
<aside class="best">If at any time you wish to provide feedback on the library
or discover unexpected behavior, please file an
<a href="https://github.com/go-fed/activity/issues/new/choose">issue</a>!
</aside>
<p>There are two key things your application needs to accomplish, which this
library will do for you:</p>
<ul>
<li>Handle an actor's inbox and outbox calls (for the SocialAPI, FederateAPI, or both)</li>
<li>Handle serving an ActivityStreams object in its raw form</li>
</ul>
<p>Before we can tackle these big items, we need to implement some interfaces
so that the library can do these default behaviors for you.</p>
<p>Firstly, the application needs to be able to fetch the current time. Rather
than hardcode calls to 
<span class="code">time.Now</span>, you will need to provide a simple clock type:</p>
<pre><span class="keyword">type</span> <span class="type">Clock</span> <span class="keyword">interface</span> {
	Now() time.<span class="type">Time</span>
}</pre>
<p>Next is the meat of your application. Overall, it needs to be able to handle
the following responsibilities regardless of which API you use:</p>
<ul>
<li>Determining if it owns an IRI</li>
<li>Getting ActivityStream content (both as verified or unverified user)</li>
<li>Determining if it has ActivityStream data at an IRI</li>
<li>Setting ActivityStream data</li>
<li>Getting an actor's outbox or inbox</li>
<li>Creating new ids</li>
<li>Obtaining the public key for another user for verification purposes</li>
<li>Whether adding/removing is permitted</li>
</ul>
<p>These responsibilities map to the following interface (comments differ from
the actual documentation):</p>
<pre><span class="keyword">type</span> <span class="type">Application</span> <span class="keyword">interface</span> {
	<span class="comment">// Determines whether the application owns an IRI</span>
	Owns(c context.<span class="type">Context</span>, id *url.<span class="type">URL</span>) <span class="type">bool</span>
	<span class="comment">// Gets ActivityStream content</span>
	Get(c context.<span class="type">Context</span>, id *url.<span class="type">URL</span>, rw <span class="type">RWType</span>) (<span class="type">PubObject</span>, <span class="type">error</span>)
	GetAsVerifiedUser(c context.<span class="type">Context</span>, id, authdUser *url.<span class="type">URL</span>, rw <span class="type">RWType</span>) (<span class="type">PubObject</span>, <span class="type">error</span>)
	<span class="comment">// Determines if it has ActivityStream data at the IRI</span>
	Has(c context.<span class="type">Context</span>, id *url.<span class="type">URL</span>) (<span class="type">bool</span>, <span class="type">error</span>)
	<span class="comment">// Setting ActivityStream data</span>
	Set(c context.<span class="type">Context</span>, o <span class="type">PubObject</span>) <span class="type">error</span>
	<span class="comment">// Getting an actor's outbox or inbox</span>
	GetInbox(c context.<span class="type">Context</span>, r *http.<span class="type">Request</span>, rw <span class="type">RWType</span>) (vocab.<span class="type">OrderedCollectionType</span>, <span class="type">error</span>)
	GetOutbox(c context.<span class="type">Context</span>, r *http.<span class="type">Request</span>, rw <span class="type">RWType</span>) (vocab.<span class="type">OrderedCollectionType</span>, <span class="type">error</span>)
	<span class="comment">// Creating new ids</span>
	NewId(c context.<span class="type">Context</span>, t <span class="type">Typer</span>) *url.<span class="type">URL</span>
	<span class="comment">// Obtaining the public key for another user for verification purposes</span>
	GetPublicKey(c context.<span class="type">Context</span>, publicKeyId <span class="type">string</span>) (pubKey crypto.<span class="type">PublicKey</span>, algo httpsig.<span class="type">Algorithm</span>, user *url.<span class="type">URL</span>, err <span class="type">error</span>)
	<span class="comment">// Whether adding/removing is permitted</span>
	CanAdd(c context.<span class="type">Context</span>, o vocab.<span class="type">ObjectType</span>, t vocab.<span class="type">ObjectType</span>) <span class="type">bool</span>
	CanRemove(c context.<span class="type">Context</span>, o vocab.<span class="type">ObjectType</span>, t vocab.<span class="type">ObjectType</span>) <span class="type">bool</span>
}</pre>
<p>Whew! That's the bulk of the work in writing an ActivityPub application right
there. Once implemented, your application will be able to handle the basic
behaviors for common activity types as outlined in the ActivityPub
specification.</p>
<p>Those of you that are observant may have noticed that there are a few other
types referenced:</p>
<ul>
<li><span class="code type">RWType</span>: Whether the read is part of a
read-only or read-write operation, which should impact any atomic locking
designs to avoid data race conditions.</li>
<li><span class="code type">PubObject</span>: All <span class="code">vocab</span>
ActivityStreams types satisfy this interface as it contains the <i>id</i> and
<i>type</i> properties' methods.</li>
<li><span class="code type">Typer</span>: All <span class="code">vocab</span>
ActivityStreams types satisfy this interface as it contains the <i>type</i>
property methods.</li>
<li><span class="code">httpsig.<span class="type">Algorithm</span></span>:
This library depends on the <span class="code">github.com/go-fed/httpsig</span>
library, which requires an algorithm.</li>
</ul>
<aside class="best">Use <span class="code">httpsig.RSA_SHA256</span> for the <span class="code">httpsig.<span class="type">Algorithm</span></span> to be compatible with the fediverse.</aside>
<p>Now that the hard part is over, you optionally can implement another
interface: the
<span class="code type">Callbacker</span>.
You will need one for either the SocialAPI or FederateAPI, but if you choose to
implement both you will need two.</p>
<p>The
<span class="code type">Callbacker</span>
is where the real customization for your application can take place. Whenever
one of its supported activity types is sent to your server, these callback
functions will be invoked. Since the basic behaviors are already handled for
you, you can focus on the custom behavior. For example, a
<span class="code type">Create</span> will already properly call your
application's functions as needed, so in the
<span class="code type">Callbacker</span>
you could have it detect if it was trying to create an
<span class="code type">Article</span>
and just have it automatically syndicate it to a proprietary social network,
for example. The precise default behavior provided for you will be explored
in depth in the API specific sections. The
<span class="code type">Callbacker</span>
looks like:</p>
<pre><span class="keyword">type</span> <span class="type">Callbacker</span> <span class="keyword">interface</span> {
	Create(c context.<span class="type">Context</span>, s *streams.<span class="type">Create</span>) <span class="type">error</span>
	Update(c context.<span class="type">Context</span>, s *streams.<span class="type">Update</span>) <span class="type">error</span>
	Delete(c context.<span class="type">Context</span>, s *streams.<span class="type">Delete</span>) <span class="type">error</span>
	Add(c context.<span class="type">Context</span>, s *streams.<span class="type">Add</span>) <span class="type">error</span>
	Remove(c context.<span class="type">Context</span>, s *streams.<span class="type">Remove</span>) <span class="type">error</span>
	Like(c context.<span class="type">Context</span>, s *streams.<span class="type">Like</span>) <span class="type">error</span>
	Block(c context.<span class="type">Context</span>, s *streams.<span class="type">Block</span>) <span class="type">error</span>
	Follow(c context.<span class="type">Context</span>, s *streams.<span class="type">Follow</span>) <span class="type">error</span>
	Undo(c context.<span class="type">Context</span>, s *streams.<span class="type">Undo</span>) <span class="type">error</span>
	Accept(c context.<span class="type">Context</span>, s *streams.<span class="type">Accept</span>) <span class="type">error</span>
	Reject(c context.<span class="type">Context</span>, s *streams.<span class="type">Reject</span>) <span class="type">error</span>
}</pre>
<p>A default implementation that does nothing for all
callbacks is perfectly valid since the ActivityPub required behavior is handled
for you by default.</p>
<aside class="caution">Note that these callbacks are given
<span class="code">stream</span>
types. These types are at risk of being deprecated in a major version
release, so upon receiving a
<span class="code">stream</span>
object, obtain the
<span class="code">vocab</span>
version by simply calling:
<span class="code">v := s.Raw()</span></aside>
<aside class="best"><p>Starting in version
<span class="code">0.3.0</span>, you may define additional methods on your
<span class="code type">Callbacker</span>
implementation to handle additional activities not required by the
<span class="code type">Callbacker</span>
interface. The methods must be of the form:
<pre>X(c context.<span class="type">Context</span>, s *streams.<span class="type">X</span>) <span class="type">error</span></pre>
where <span class="code">X</span> is one of the following types:
<ul>
<li><span class="code type">Announce</span></li>
<li><span class="code type">Arrive</span></li>
<li><span class="code type">Dislike</span></li>
<li><span class="code type">Flag</span></li>
<li><span class="code type">Ignore</span></li>
<li><span class="code type">Invite</span></li>
<li><span class="code type">Join</span></li>
<li><span class="code type">Leave</span></li>
<li><span class="code type">Listen</span></li>
<li><span class="code type">Move</span></li>
<li><span class="code type">Offer</span></li>
<li><span class="code type">Question</span></li>
<li><span class="code type">Read</span></li>
<li><span class="code type">TentativeAccept</span></li>
<li><span class="code type">TentativeReject</span></li>
<li><span class="code type">Travel</span></li>
<li><span class="code type">View</span></li>
</ul>
</p></aside>
<p>Now that these interfaces are implemented, you can create a
<span class="code type">Pubber</span>
type. What does this do for you? Why use a funky naming thing? Why am I talking
to myself? Well, it handles HTTP requests to an actor's inbox or outbox and
carries out the ActivityPub-specific behavior required for the API(s) you wish
to support. This is one of the two big behaviors mentioned at the beginning of
this section. To get a
<span class="code type">Pubber</span>
requires calling a constructor.
The exact constructor you call depends on which API(s) you wish to
support, and so this will be addressed in the sections below. For now, let's
assume you've already done that and have a shiny new
<span class="code type">Pubber</span>
ready to get going.</p>
<p>What can you do with a
<span class="code type">Pubber</span>?
Well, it's API is straightforward:</p>
<pre><span class="keyword">type</span> <span class="type">Pubber</span> <span class="keyword">interface</span> {
	<span class="comment">// Handle a HTTP request to an actor's inbox</span>
	PostInbox(c context.<span class="type">Context</span>, w http.<span class="type">ResponseWriter</span>, r *http.<span class="type">Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
	GetInbox(c context.<span class="type">Context</span>, w http.<span class="type">ResponseWriter</span>, r *http.<span class="type">Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
	<span class="comment">// Handle a HTTP request to an actor's outbox</span>
	PostOutbox(c context.<span class="type">Context</span>, w http.<span class="type">ResponseWriter</span>, r *http.<span class="type">Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
	GetOutbox(c context.<span class="type">Context</span>, w http.<span class="type">ResponseWriter</span>, r *http.<span class="type">Request</span>) (<span class="type">bool</span>, <span class="type">error</span>)
}</pre>
<p>So whatever handler you have to handle an actor's inbox or outbox would look
similar to this:</p>
<pre><span class="comment">// Given:</span>
<span class="comment">//     var myPubber pub.Pubber</span>
var outboxHandler http.<span class="type">HandlerFunc</span> = <span class="type">func</span>(w http.<span class="type">ResponseWriter</span>, r *http.<span class="type">Request</span>) {
	c := context.Background()
	<span class="comment">// Populate c with application specific information here</span>
	<span class="comment">// ...</span>
	if handled, err := myPubber.PostOutbox(c, w, r); err != <span class="literal">nil</span> {
	  <span class="comment">// Write to w</span>
	} else if handled {
	  return
	}
	if handled, err := myPubber.GetOutbox(c, w, r); err != <span class="literal">nil</span> {
	  <span class="comment">// Write to w</span>
	} else if handled {
	  return
	}
	<span class="comment">// Handle non-ActivityPub request, such as responding with a HTML</span>
	<span class="comment">// representation with correct view permissions.</span>
}
var inboxHandler http.<span class="type">HandlerFunc</span> = func(w http.<span class="type">ResponseWriter</span>, r *http.<span class="type">Request</span>) {
	c := context.Background()
	<span class="comment">// Populate c with application specific information here</span>
	<span class="comment">// ...</span>
	if handled, err := myPubber.PostInbox(c, w, r); err != <span class="literal">nil</span> {
	  <span class="comment">// Write to w</span>
	} else if handled {
	  return
	}
	if handled, err := myPubber.GetInbox(c, w, r); err != <span class="literal">nil</span> {
	  <span class="comment">// Write to w</span>
	} else if handled {
	  return
	}
	<span class="comment">// Handle non-ActivityPub request, such as responding with a HTML</span>
	<span class="comment">// representation with correct view permissions.</span>
}</pre>
<p>That handles one of the two big behaviors! The other behavior is to handle
serving the raw
ActivityStream data at the URL endpoint that matches its <i>id</i> property.
There are two ways to do this: one function provides default HTTP Signature
checking, and the other lets you use your own custom
authentication/authorization method.</p>
<pre><span class="comment">// Given:</span>
<span class="comment">//     var myApp pub.Application</span>
<span class="comment">//     var myClock pub.Clock</span>
<span class="comment">//     var myVerifier pub.SocialAPIVerifier - This type to be discussed in a later section</span>
var myPubHandler pub.<span class="type">HandlerFunc</span> = pub.ServeActivityPubObject(myApp, myClock)
<span class="comment">// Alternatively:</span>
myVerifierFactory = <span class="type">func</span>(c context.<span class="type">Context</span>) pub.<span class="type">SocialAPIVerifier</span> {
	<span class="comment">// ...</span>
	<span class="keyword">return</span> myVerifier
}
var myCustomVerifiedPubHandler pub.<span class="type">HandlerFunc</span> = pub.ServeActivityPubObjectWithVerificationMethod(myApp, myClock, myVerifierFactory)
<span class="comment">// Serve ActivityStreams objects:</span>
var serveIRIHandler http.<span class="type">HandlerFunc</span> = <span class="type">func</span>(w http.<span class="type">ResponseWriter</span>, r *http.<span class="type">Request</span>) {
	c := context.Background()
	<span class="comment">// Populate c with application specific information here</span>
	<span class="comment">// ...</span>
	if handled, err := myPubHandler(c, w, r) <span class="comment">/* or myCustomVerifiedPubHandler */</span>; err != <span class="literal">nil</span> {
	  	  <span class="comment">// Write to w</span>
	} else if handled {
	  return
	}
	<span class="comment">// Handle non-ActivityPub request, such as responding with a HTML</span>
	<span class="comment">// representation with correct view permissions.</span>
}</pre>
<p>And that's about all it takes to hook ActivityPub behaviors into your new or
existing application!</p>
<p>Now that you have the basics, it is time to explore the specific requirements
and specific default behaviors
for each of the APIs in ActivityPub. As well as how to create the
<span class="code type">Pubber</span>
type.</p>
<h2 id="ActivityPub-SocialAPI">ActivityPub: SocialAPI (Client to Server)</h2>
<p>The SocialAPI provides the following default behaviors for the following
activities (heavily summarized):</p>
<ul>
<li><span class="code type">Create</span>: Creating a new <i>id</i> and setting the new object in the <span class="code type">Application</span>.</li>
<li><span class="code type">Update</span>: Partially updating an existing object.</li>
<li><span class="code type">Delete</span>: Setting an existing object as a <span class="code type">Tombstone</span>.</li>
<li><span class="code type">Add</span>: Adds an object to a target <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span>, if <span class="code type">Application</span> permits it.</li>
<li><span class="code type">Remove</span>: Removes an object from a target <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span>, if <span class="code type">Application</span> permits it.</li>
<li><span class="code type">Like</span>: Adds a like to the appropriate <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span>.</li>
</ul>
<aside class="best">Customize these behaviors by implementing a
<span class="code type">Callbacker</span>! Call your local salesperson today!</aside>
<p>Now, to obtain a
<span class="code type">Pubber</span>
you will need to call:</p>
<pre><span class="type">func</span> NewSocialPubber(
	clock <span class="type">Clock</span>,
	app <span class="type">SocialApplication</span>,
	cb <span class="type">Callbacker</span>) <span class="type">Pubber</span></pre>
<p>You should have the
<span class="code type">Clock</span>
and
<span class="code type">Callbacker</span>
from the previous section
<a href="#ActivityPub-The-Two-Protocols">ActivityPub: The Two Protocols</a>.
However, the
<span class="code type">SocialApplication</span>
is defined as:</p>
<pre><span class="keyword">type</span> <span class="type">SocialApplication</span> <span class="keyword">interface</span> {
	<span class="type">Application</span>
	<span class="type">SocialAPI</span>
}</pre>
<p>And since you already have an
<span class="code type">Application</span>
you just have to implement the methods in
<span class="code type">SocialAPI</span>,
which provide the following necessary behaviors for this library:</p>
<ul>
<li>Determine the actor's id for a given HTTP request, typically by examining the request URL path.</li>
<li>Optionally use a custom authentication/authorization method besides HTTP Signatures (the default).</li>
<li>Obtain a public key for an actor's outbox to ensure the user is authentic when verifying with HTTP Signatures (the default).</li>
</ul>
<p>This is how it looks as an interface (comments differ from the source):</p>
<pre><span class="keyword">type</span> <span class="type">SocialAPI</span> <span class="keyword">interface</span> {
	<span class="comment">// Determine an actor's id</span>
	ActorIRI(c context.<span class="type">Context</span>, r *http.<span class="type">Request</span>) (*url.<span class="type">URL</span>, <span class="type">error</span>)
	<span class="comment">// Optional authentication/authorization scheme</span>
	GetSocialAPIVerifier(c context.<span class="type">Context</span>) <span class="type">SocialAPIVerifier</span>
	<span class="comment">// Gets an actor's public key for verifying incoming messages</span>
	GetPublicKeyForOutbox(c context.<span class="type">Context</span>, publicKeyId <span class="type">string</span>, boxIRI *url.<span class="type">URL</span>) (crypto.<span class="type">PublicKey</span>, httpsig.<span class="type">Algorithm</span>, <span class="type">error</span>)
}</pre>
<p>This introduces us to our final interface:
<span class="code type">SocialAPIVerifier</span>.
It is only necessary if you want to implement OAuth 2.0 or some other
authentication/authorization scheme besides the default HTTP Signatures.
Its interface is simple but nuanced:</p>
<pre><span class="keyword">type</span> <span class="type">SocialAPIVerifier</span> <span class="keyword">interface</span> {
	Verify(r *http.<span class="type">Request</span>) (authenticatedUser *url.<span class="type">URL</span>, authn, authz <span class="type">bool</span>, err <span class="type">error</span>)
	VerifyForOutbox(r *http.<span class="type">Request</span>, outbox *url.<span class="type">URL</span>) (authn, authz <span class="type">bool</span>, err <span class="type">error</span>)
}</pre>
<aside class="caution">Check the documentation to ensure that the returned
results will behave in the manner you expect!</aside>
<p>That's it! With your knowledge from this section as well as the
<a href="#ActivityPub-The-Two-Protocols">ActivityPub: The Two Protocols</a>
section, you are good to build an application using ActivityPub's SocialAPI protocol.</p>
<h2 id="ActivityPub-FederateAPI">ActivityPub: FederateAPI (Server to Server)</h2>
<p>The FederateAPI provides the following default behaviors for the following
activities (heavily summarized):</p>
<ul>
<li><span class="code type">Create</span>: Sets a new object in the <span class="code type">Application</span>.</li>
<li><span class="code type">Update</span>: Replaces an existing object in the <span class="code type">Application</span>.</li>
<li><span class="code type">Delete</span>: Turns an existing object into a <span class="code type">Tombstone</span>.</li>
<li><span class="code type">Follow</span>: Adds to a <i>followers</i> <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span> if auto-approve or auto-reject is enabled.</li>
<li><span class="code type">Accept</span>:Adds to a <i>following</i> <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span> if a <span class="code type">Follow</span> was accepted.</li>
<li><span class="code type">Add</span>: Adds an object to a target <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span>, if <span class="code type">Application</span> permits it.</li>
<li><span class="code type">Remove</span>: Removes an object from a target <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span>, if <span class="code type">Application</span> permits it.</li>
<li><span class="code type">Like</span>: Adds a like to the appropriate <span class="code type">Collection</span> or <span class="code type">OrderedCollection</span>.</li>
</ul>
<aside class="best">Customize these behaviors by implementing a
<span class="code type">Callbacker</span>! Call your local salesperson today!</aside>
<aside class="best"><p>Starting in version
<span class="code">0.3.0</span>, the
<span class="code type">Announce</span>
activity's default behavior is also supported in the Federate API. It adds the 
<span class="code type">Announce</span>
to the <i>shares</i>
<span class="code type">Collection</span>
or
<span class="code type">OrderedCollection</span>
on the object being announced, if owned by your application.
</p></aside>
<p>This will let you federate with peer servers, but without the SocialAPI
your application will presumably need some other mechanism for users to create
content. Once created, this library will take care of federating with peers.</p>
<p>It also solves the "ghost replies" problem for you. This is when Alex
publicly replies to a message from Addison, but the message is not forwarded
to Addison's followers. If Addison then replies again, her followers would see
Addison's original message and reply, but not Alex's reply in the middle. This
library solves that problem for you by having Addison's server forward Alex's
message to Addison's followers.</p>
<p>To obtain a
<span class="code type">Pubber</span>
you will need to call:</p>
<pre><span class="type">func</span> NewFederatingPubber(
	clock <span class="type">Clock</span>,
	app <span class="type">FederateApplication</span>,
	cb <span class="type">Callbacker</span>,
	d <span class="type">Deliverer</span>,
	client <span class="type">HttpClient</span>,
	userAgent <span class="type">string</span>,
	maxDeliveryDepth, maxForwardingDepth <span class="type">int</span>) <span class="type">Pubber</span></pre>
<p>You should have the
<span class="code type">Clock</span>
and
<span class="code type">Callbacker</span>
from the previous section
<a href="#ActivityPub-The-Two-Protocols">ActivityPub: The Two Protocols</a>.
It also requires a
<span class="code type">FederateApplication</span>,
<span class="code type">Deliverer</span>,
<span class="code type">HttpClient</span>,
<span class="code">userAgent</span>,
<span class="code">maxDeliveryDepth</span>, and
<span class="code">maxForwardingDepth</span>.
The
<span class="code type">FederateApplication</span>
is defined as:</p>
<pre><span class="keyword">type</span> <span class="type">FederateApplication</span> <span class="keyword">interface</span> {
	<span class="type">Application</span>
	<span class="type">FederateAPI</span>
}</pre>
<p>And since you already have an
<span class="code type">Application</span>
you just have to implement the methods in
<span class="code type">FederateAPI</span>,
which provide the following necessary behaviors for this library:</p>
<ul>
<li>How to handle follow requests (auto-approve, auto-reject, manually decide).</li>
<li>Whether an interaction should be blocked.</li>
<li>Filter recipients when forwarding messages in order to avoid "ghost replies".</li>
<li>Sign federated messages with HTTP Signatures.</li>
<li>Obtain private and public keys for proper signing.</li>
</ul>
<p>This is how it looks as an interface (comments differ from the source):</p>
<pre><span class="keyword">type</span> <span class="type">FederateAPI</span> <span class="keyword">interface</span> {
	<span class="comment">// How to handle follow requests (auto-approve, auto-reject, manually decide)</span>
	OnFollow(c context.<span class="type">Context</span>, s *streams.<span class="type">Follow</span>) <span class="type">FollowResponse</span>
	<span class="comment">// Whether an interaction should be blocked</span>
	Unblocked(c context.<span class="type">Context</span>, actorIRIs []*url.<span class="type">URL</span>) <span class="type">error</span>
	<span class="comment">// Filter recipients when forwarding messages in order to avoid "ghost replies"</span>
	FilterForwarding(c context.<span class="type">Context</span>, activity vocab.<span class="type">ActivityType</span>, iris []*url.<span class="type">URL</span>) ([]*url.<span class="type">URL</span>, <span class="type">error</span>)
	<span class="comment">// Sign federated messages with HTTP Signatures</span>
	NewSigner() (httpsig.<span class="type">Signer</span>, <span class="type">error</span>)
	<span class="comment">// Obtain private and public keys for proper signing</span>
	PrivateKey(boxIRI *url.<span class="type">URL</span>) (privKey crypto.<span class="type">PrivateKey</span>, pubKeyId <span class="type">string</span>, err <span class="type">error</span>)
}</pre>
<aside class="caution">You must apply some sort of filtering mechanism
in the <span class="code">FilterForwarding</span> method or else your
application is at risk of becoming a source for unintentional DDOSing
of peers. A simple filter would be: ensure all
<span class="code">iris</span> are followers of the <i>to</i> and
<i>cc</i> recipients on the <span class="code">Activity</span>.</aside>
<p>Next is the
<span class="code type">Deliverer</span>.
Since this library is sending HTTP requests on your application's behalf, there
needs to be some way to handle retries, backing off, and persistent state if a
request needs to be retried after downtime. The
<span class="code type">Deliverer</span>
implementation you write can be as fancy as you wish:</p>
<pre><span class="keyword">type</span> <span class="type">Deliverer</span> <span class="keyword">interface</span> {
	Do(b []<span class="type">byte</span>, to *url.<span class="type">URL</span>, toDo <span class="type">func</span>(b []<span class="type">byte</span>, u *url.<span class="type">URL</span>) <span class="type">error</span>)
}</pre>
<p>The naive implementation is simply:</p>
<pre><span class="keyword">type</span> <span class="type">NaiveDeliverer</span> <span class="keyword">struct</span> {}

<span class="type">func</span> (d *<span class="type">NaiveDeliverer</span>) Do(b []<span class="type">byte</span>, to *url.<span class="type">URL</span>, toDo <span class="type">func</span>(b []<span class="type">byte</span>, u *url.<span class="type">URL</span>) <span class="type">error</span>) {
	_ = toDo(b, to)
}</pre>
<p>The final new type is the
<span class="code type">HttpClient</span>.
Since this library is sending HTTP requests on your application's behalf, you
remain in full control of the actual HTTP delivery mechanism. It should be no
surprise that
<span class="code">http.<span class="type">Client</span></span>
implements this interface:</p>
<pre><span class="keyword">type</span> <span class="type">HttpClient</span> <span class="keyword">interface</span> {
	Do(req *http.<span class="type">Request</span>) (*http.<span class="type">Response</span>, <span class="type">error</span>)
}</pre>
<p>The final options in the call to
<span class="code">NewFederatingPubber</span>
are settings used to govern details in the behavior of your application:</p>
<ul>
<li><span class="code">userAgent</span>: Your application-specific string to be included in the user agent. The go-fed library includes itself as well.</li>
<li><span class="code">maxDeliveryDepth</span>: The maximum recursive iterations when resolving inboxes (must be &gt;= 1).</li>
<li><span class="code">maxForwardingDepth</span>: The maximum recursive iterations when looking to forward messages to avoid the "ghost reply" problem (must be &gt;= 1).</li>
</ul>
<p>And with that, you have your
<span class="code">Pubber</span>
and a way to federate! With this section as well as the
<a href="#ActivityPub-The-Two-Protocols">ActivityPub: The Two Protocols</a>
section, you can build an application using ActivityPub's FederateAPI protocol.</p>
<h2 id="ActivityPub-Both-APIs">ActivityPub: Both APIs (Client to Server &amp; Server to Server)</h2>
<p>Surprise, you can implement both the SocialAPI and FederateAPI portions of
ActivityPub using this library! Unsurprisingly, the way to create a
<span class="code type">Pubber</span>
in this case is both of the
<span class="code">NewSocialPubber</span> and
<span class="code">NewFederatingPubber</span>
functions squished into one. <i>Squish</i> is a highly technical term:</p>
<pre><span class="type">func</span> NewPubber(
	clock <span class="type">Clock</span>,
	app <span class="type">SocialFederateApplication</span>,
	client, server <span class="type">Callbacker</span>,
	d <span class="type">Deliverer</span>,
	httpClient <span class="type">HttpClient</span>,
	userAgent <span class="type">string</span>,
	maxDeliveryDepth, maxForwardingDepth <span class="type">int</span>) <span class="type">Pubber</span></pre>
<p>The
<span class="code type">SocialFederateApplication</span>
type is simply:</p>
<pre><span class="keyword">type</span> <span class="type">SocialFederateApplication</span> <span class="keyword">interface</span> {
	<span class="type">Application</span>
	<span class="type">SocialAPI</span>
	<span class="type">FederateAPI</span>
}</pre>
<p>Follow the guidance in the other two sections to know more about these
parameters and their types:</p>
<ul>
<li><a href="#ActivityPub-SocialAPI">ActivityPub: Social API</a></li>
<li><a href="#ActivityPub-FederateAPI">ActivityPub: Federate API</a></li>
</ul>
<aside class="caution">There are <b>two</b> <span class="code type">Callbacker</span>
objects required when using both APIs. This lets you distinguish between an
Activity being received by a user via the SocialAPI (<span class="code">client</span>)
and one being received from a peer via the FederateAPI (<span class="code">server</span>),
as you will want to treat these use cases differently.</aside>
<h2 id="References">References</h2>
<p>These are the references I used or referred to when building all libraries within
the go-fed organization, including but not limited to the
<span class="code">go-fed/activity</span> library.</p>
<p>W3C Specifications:</p>
<ul>
<li><a href="https://www.w3.org/TR/social-web-protocols/">Social Web Protocols</a></li>
<li><a href="https://www.w3.org/TR/activitypub">The ActivityPub Specification</a></li>
<li><a href="https://www.w3.org/TR/activitystreams-core">The ActivityStreams Core Specification</a></li>
<li><a href="https://www.w3.org/TR/activitystreams-vocabulary">The ActivityStreams Vocabulary</a></li>
<li><a href="https://www.w3.org/ns/activitystreams">ActivityStream 2.0 Terms</a></li>
<li><a href="https://www.w3.org/TR/json-ld">The JSON-LD Specification</a></li>
</ul>
<p>RFCs:</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc3987">RFC 3987: Internationalized Resource Identifiers (IRIs)</a></li>
<li><a href="https://tools.ietf.org/html/rfc7033">RFC 7033: Webfinger</a></li>
<li><a href="https://tools.ietf.org/html/rfc3230">RFC 3230: Instance Digests in HTTP</a></li>
<li><a href="https://tools.ietf.org/html/rfc6749">RFC 6749: The OAuth 2.0 Authorization Framework</a></li>
<li><a href="https://tools.ietf.org/html/rfc6750">RFC 6750: The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></li>
<li><a href="https://tools.ietf.org/html/draft-cavage-http-signatures-10">DRAFT: Signing HTTP Messages</a></li>
</ul>
<p>Other documents and links:</p>
<ul>
<li><a href="https://www.w3.org/wiki/SocialCG/ActivityPub/Authentication_Authorization">ActivityPub Authentication And Authorization Conventions</a></li>
<li><a href="https://github.com/w3c/activitystreams">Github Repo for W3C ActivityStreams</a></li>
<li><a href="https://github.com/w3c/activitypub">Github Repo for W3C ActivityPub</a></li>
<li><a href="https://github.com/w3c-dvcg/http-signatures">Github Repo for W3C Draft of HTTP Signatures</a></li>
</ul>
{{template "footer" .C}}{{end}}
